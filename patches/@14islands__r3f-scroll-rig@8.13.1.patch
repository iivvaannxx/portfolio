diff --git a/changelog.md b/changelog.md
deleted file mode 100644
index 2c097a5bf0df66cf3907e7dc1789c0e03a723275..0000000000000000000000000000000000000000
diff --git a/dist/powerups.modern.js b/dist/powerups.modern.js
index 8ac24f66487f7188129e656794bb4357317cf944..8c25be4db2ef5f8aa59f91bfbe1b9e20b0f5274f 100644
--- a/dist/powerups.modern.js
+++ b/dist/powerups.modern.js
@@ -1,2 +1,2 @@
-import e,{useMemo as t,useEffect as r,forwardRef as i,useRef as n,useImperativeHandle as o}from"react";import{useThree as s,useFrame as l}from"@react-three/fiber";import{Text as a}from"@react-three/drei";import{useScrollRig as u,useScrollbar as c,useImageAsTexture as m,ScrollScene as h}from"@14islands/r3f-scroll-rig";import{Color as p,Vector2 as f}from"three";function d(){return d=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(e[i]=r[i])}return e},d.apply(this,arguments)}function g(e,t){if(null==e)return{};var r,i,n={},o=Object.keys(e);for(i=0;i<o.length;i++)t.indexOf(r=o[i])>=0||(n[r]=e[r]);return n}const v=["el","children","material","scale","font","fontOffsetY","fontOffsetX","overrideEmissive","color"],y=i=>{let{el:n,children:o,material:l,scale:c,font:m,fontOffsetY:h=0,fontOffsetX:p=0,overrideEmissive:f=!1,color:y}=i,w=g(i,v);const{size:b}=s(),{scaleMultiplier:S}=u(),{textColor:E,fontSize:A,textAlign:x,lineHeight:_,letterSpacing:N}=t(()=>{if(!n.current)return{};const e=window.getComputedStyle(n.current);let t=y||e.color;return!y&&"rgba(0, 0, 0, 0)"===e.color&&n.current.parentElement&&(t=window.getComputedStyle(n.current.parentElement).color),{letterSpacing:(parseFloat(e.letterSpacing)||0)/parseFloat(e.fontSize),lineHeight:(parseFloat(e.lineHeight)||0)/parseFloat(e.fontSize),textColor:t,fontSize:parseFloat(e.fontSize)*S,textAlign:e.textAlign}},[n,b,c,y,S]);r(()=>{l&&f&&(l.emissive=y)},[l,y,f]);let z=0;return"left"===x||"start"===x?z=-.5*c[0]:"right"!==x&&"end"!==x||(z=.5*c[0]),e.createElement(a,d({fontSize:A,maxWidth:c?c[0]:b.width,lineHeight:_,textAlign:x,letterSpacing:N,overflowWrap:"break-word",font:m,color:E,anchorX:x,anchorY:"top",position:[z+A*p,(c?.5*c[1]:.5*b.height)+A*h,0],material:l},w),o)},w=["el","scale","scrollState","vertexShader","fragmentShader","invalidateFrameLoop","widthSegments","heightSegments"],b=i((i,a)=>{let{el:h,scale:v,scrollState:y,vertexShader:b,fragmentShader:S,invalidateFrameLoop:E=!1,widthSegments:A=128,heightSegments:x=128}=i,_=g(i,w);const N=n(null),z=n(null);o(a,()=>z.current);const{invalidate:M,gl:T,size:k}=s(),O=s(e=>e.viewport.dpr),{scroll:V}=c(),{scaleMultiplier:R}=u(),F=m(h),P=t(()=>({u_color:{value:new p("black")},u_time:{value:0},u_pixelRatio:{value:O},u_progress:{value:0},u_visibility:{value:0},u_viewport:{value:0},u_velocity:{value:0},u_res:{value:new f},u_rect:{value:new f},u_size:{value:new f},u_texture:{value:null},u_loaded:{value:!1},u_scaleMultiplier:{value:R}}),[O]);r(()=>{F&&N.current&&(N.current.uniforms.u_texture.value=F,N.current.uniforms.u_size.value.set(F.image.width,F.image.height),N.current.uniforms.u_loaded.value=!0)},[F,T]),r(()=>{N.current&&(N.current.uniforms.u_res.value.set(k.width,k.height),N.current.uniforms.u_rect.value.set(null==v?void 0:v[0],null==v?void 0:v[1]))},[k,v]),l((e,t)=>{y.inViewport&&z.current&&N.current&&N.current.uniforms.u_loaded.value&&(N.current.uniforms.u_time.value+=t,N.current.uniforms.u_rect.value.set(z.current.scale.x,z.current.scale.y),N.current.uniforms.u_velocity.value=V.velocity,N.current.uniforms.u_progress.value=y.progress,N.current.uniforms.u_visibility.value=y.visibility,N.current.uniforms.u_viewport.value=y.viewport,E&&M())});const L=t(()=>[{vertexShader:b,fragmentShader:S}],[b,S]);return e.createElement(e.Fragment,null,e.createElement("mesh",d({ref:z},_),e.createElement("planeGeometry",{attach:"geometry",args:[1,1,A,x]}),e.createElement("shaderMaterial",{ref:N,args:L,transparent:!0,uniforms:P})))}),S=["children","speed"],E=({children:t,scrollState:r,parallax:i})=>{const o=n(null),a=s(e=>e.size),{scaleMultiplier:c}=u();return l(()=>{r.inViewport&&(o.current.position.y=i*(2*r.progress-1)*c*a.height)}),e.createElement("mesh",{ref:o},t)},A=t=>{let{children:r,speed:i=1}=t,n=g(t,S);const o=i-1;return e.createElement(h,d({scissor:!1,inViewportMargin:200*Math.max(0,.5)+50+"%"},n),t=>e.createElement(E,d({parallax:o},t),r(t)))};let x=new Proxy({},{get:function(e,t){return e.hasOwnProperty(t)||(e[t]=z(t)),e[t]}});class _ extends Array{constructor(e,t){if(!(t=O(t)).every(e=>"Number"===R(e)))throw new TypeError("All arguments must be numbers.");if(t.length>1&&t.length!==e)throw new Error("Argument list must be empty, have a single number, or have a length equal to the dimension.");0===t.length&&(t=[0]),1===t.length&&"Number"===R(t[0])&&(t=Array(e).fill(t[0])),e>1?super(...t):(super(1),this[0]=t[0]),Reflect.defineProperty(this,"pop",{value:void 0,enumerable:!1}),Reflect.defineProperty(this,"push",{value:void 0,enumerable:!1}),Reflect.defineProperty(this,"shift",{value:void 0,enumerable:!1}),Reflect.defineProperty(this,"unshift",{value:void 0,enumerable:!1})}get magnitude(){return this.pnorm(2)}div(e){k(e,this.dim,!0),"Number"===R(e)&&(e=new Array(this.dim).fill(e));let t=[];for(let r=0;r<this.length;++r)t[r]=this[r]/e[r];return x[this.dim](t)}minus(e){k(e,this.dim,!0),"Number"===R(e)&&(e=new Array(this.dim).fill(e));let t=[];for(let r=0;r<this.dim;++r)t[r]=this[r]-e[r];return x[this.dim](t)}neg(){return x[this.dim](this.times(-1))}plus(e){k(e,this.dim,!0),"Number"===R(e)&&(e=new Array(this.dim).fill(e));let t=[];for(let r=0;r<this.dim;++r)t[r]=this[r]+e[r];return x[this.dim](t)}pow(e){let t=[];for(let r=0;r<this.dim;++r)t[r]=Math.pow(this[r],e);return x[this.dim](t)}times(e){k(e,this.dim,!0),"Number"===R(e)&&(e=new Array(this.dim).fill(e));let t=[];for(let r=0;r<this.dim;++r)t[r]=this[r]*e[r];return x[this.dim](t)}dot(e){k(e,this.dim);let t=0;for(let r=0;r<this.dim;++r)t+=this[r]*e[r];return t}normalize(){return this.div(this.magnitude)}pnorm(e){let t=0;for(let r=0;r<this.dim;++r)t+=Math.pow(Math.abs(this[r]),e);return Math.pow(t,1/e)}reflect(e){const t=e.normalize();return this.minus(t.times(2*this.dot(t)))}argmax(){const e=this.max();return this.reduce((t,r,i)=>r===e?t.concat([i]):t,[])}argmin(){const e=this.min();return this.reduce((t,r,i)=>r===e?t.concat([i]):t,[])}choose(e){if(!Array.isArray(e))throw new TypeError("Argument must be a list of indices.");if(!e.every(e=>e<this.dim&&V(e.toString())))throw new RangeError("All elements of argument must be valid indices.");let t=[];return e.forEach(e=>t.push(this[e])),x[t.length](t)}copy(){return x[this.dim](this)}equals(e){return e.length===this.dim&&e.every((e,t)=>this[t]===e)}approximatelyEquals(e,t=1e-8){return e.length===this.dim&&e.every((e,r)=>Math.abs(this[r]-e)<t)}max(){return Math.max(...this)}min(){return Math.min(...this)}sum(){return this.reduce((e,t)=>e+t,0)}toArray(){return Array.from(this)}concat(...e){const t=super.concat.apply(this.toArray(),e);return x[t.length](t)}filter(...e){const t=super.filter.apply(this.toArray(),e);return t.length>0?x[t.length](t):t}map(...e){const t=super.map(...e);return t.every(e=>"Number"===R(e))?t:t.toArray()}slice(...e){const t=super.slice.apply(this.toArray(),e);return t.length>0?x[t.length](t):t}splice(...e){let t=this.toArray();if(t.splice(...e),t.length!==this.dim)throw new Error("All removed elements must be replaced.");if(!t.every(e=>"Number"===R(e)))throw new TypeError("All elements must be numbers.");t.forEach((e,t)=>{this[t]=e})}toString(){return this.reduce((e,t,r)=>e+t+(r===this.dim-1?" ":", "),"[ ")+"]"}}const N={set:function(e,t,r){if("length"===t)return!1;if(V(t)){if(Number(t)>=e.dim)throw new RangeError("Vector may not have more elements than dimension.");if("Number"!==R(r))throw new TypeError("Vectors may only contain numbers.");return e[t]=r,!0}const i=T(t.toString());return!!(e.dim<=4&&i)&&(function(e,t,r,i){if(1===t.length){if("Number"!==R(i))throw new TypeError("Must set to a number");return void(e[r[t]]=i)}if(!Array.isArray(i))throw new TypeError("Right-hand side must be an array.");if(t.length!==i.length)throw new TypeError("Right-hand side must have matching length.");if(!i.every(e=>"Number"===R(e)))throw new TypeError("All new values must be numbers.");if(t.split("").some(t=>r[t]>=e.dim))return;let n=!0;for(let e=0,r={};e<t.length;++e){if(r.hasOwnProperty(t[e])){n=!1;break}r[t[e]]=!0}if(!n)throw new SyntaxError("Swizzle assignment does not allow symbols to be repeated.");t.split("").map(e=>r[e]).forEach((t,r)=>{e[t]=i[r]})}(e,t.toString(),i,r),!0)},get:function(e,t){const r=T(t.toString());return e.dim<=4&&r?function(e,t,r){const i=t.length;if(1===i)return e[r[t]];let n=t.split("").reduce((t,i)=>{let n=r[i];return t&&n<e.dim?t.concat([e[n]]):void 0},[]);return n?new x[i](...n):void 0}(e,t,r):e[t]}};function z(e){if(!((e=Number(e))in x)){if(isNaN(e))throw new TypeError("Dimension must be coercible to a number.");if(e<=0)throw new RangeError("Dimension must be positive.");if(!Number.isInteger(e))throw new RangeError("Dimension must be positive.");let t="vec"+e,r={[t]:class extends _{constructor(...t){if(1===t.length&&t[0]instanceof _){if(t[0].dim>e)throw new TypeError("Cannot demote vectors.");t=function(e,t){return[...Array(t)].map((t,r)=>r<e.length?e[r]:0)}(t[0].toArray(),e)}super(e,t),Reflect.defineProperty(this,"dim",{value:e,writable:!1,enumerable:!1})}}}[t];x[e]=function(...e){let t=new r(...e);return Object.preventExtensions(t),new Proxy(t,N)}}return x[e]}const M=[{x:0,y:1,z:2,w:3},{r:0,g:1,b:2,a:3},{s:0,t:1,p:2,q:3}];function T(e){return M.find(t=>e.split("").every(e=>e in t))}function k(e,t,r=!1){if(!(r&&"Number"===R(e)||e.length&&e.length===t))throw new TypeError(`Invalid argument. Input must have matching dimension${r?"or be a scalar":""}.`)}function O(e){return e instanceof Array&&1===e.length&&e[0]instanceof Array?O(e[0]):e}function V(e){return!isNaN(e)&&Number(e).toString()===e&&Number.isInteger(Number(e))&&Number(e)>=0}function R(e){return Object.prototype.toString.call(e).slice(8,-1)}var F={getVecType:z,isVec:function(e){return e instanceof _},vec2:x[2],vec3:x[3],vec4:x[4],add:function(...e){const t=e[0].dim;if(!e.every(e=>e.dim===t))throw new TypeError("All vectors must have the same dimension.");return e.reduce((e,t)=>e.plus(t),x[t]())},multiply:function(...e){const t=e[0].dim;if(!e.every(e=>e.dim===t))throw new TypeError("All vectors must have the same dimension.");return e.reduce((e,t)=>e.times(t),x[t](1))},lerp:function(e,t,r){if(e.dim!==t.dim)throw new TypeError("Vectors must have the same dimension.");return r=r<0?0:r>1?1:r,e.plus(t.minus(e).times(r))},slerp:function(e,t,r){if(e.dim!==t.dim)throw new TypeError("Vectors must have the same dimension.");r=r<0?0:r>1?1:r;let i=e.normalize().dot(t.normalize());i=i<-1?-1:i>1?1:i;const n=Math.acos(i)*r,o=t.minus(e.times(i)).normalize(),s=e.magnitude+(t.magnitude-e.magnitude)*r;return e.times(Math.cos(n)).plus(o.times(Math.sin(n))).normalize().times(s)}};const P=["scale"],L=["children","track","stickyLerp","fillViewport"],C=({children:t,childTop:r,childBottom:i,scrollState:o,parentScale:a,childScale:u,scaleMultiplier:c,priority:m,stickyLerp:h=1,offsetTop:p=0})=>{const f=n(null),d=s(e=>e.size);return l((e,t)=>{if(!o.inViewport)return;const n=.5*a[1]-.5*u[1]-p*c;let s=f.current.position.y;s=o.viewport+(r-p)/d.height<1?n:o.visibility-i/a[1]*c<1?-r*c+n-(o.viewport-1)*d.height*c+p*c:.5*-a[1]+.5*u[1],f.current.position.y=function(e,t,r,i,n=60){return o=t,e*(1-(s=void 0===i?r:1-Math.pow(1-r,i/(1/n))))+o*s;var o,s}(f.current.position.y,s,h,t)},m),e.createElement("group",{ref:f},t)},j=r=>{let{children:i,track:o,stickyLerp:l,fillViewport:a}=r,c=g(r,L);const m=s(e=>e.size),{scaleMultiplier:p}=u(),f=n(o.current),v=t(()=>{const e=getComputedStyle(o.current);return"sticky"===e.position?(f.current=o.current.parentElement,"static"===getComputedStyle(f.current).position&&console.error("StickyScrollScene: parent of position:sticky needs to be position:relative or position:absolute (currently set to position:static)")):console.error("StickyScrollScene: tracked element is not position:sticky"),e},[o]);return e.createElement(h,d({track:f},c),((t,r,i,n,o,{stickyLerp:s,fillViewport:l})=>a=>{let{scale:u}=a,c=g(a,P),m=F.vec3(parseFloat(n.width),parseFloat(n.height),1),h=parseFloat(n.top),p=i.height-h-m[1];return l&&(m=F.vec3(i.width,i.height,1),h=0,p=0),e.createElement(C,d({offsetTop:t.current.offsetTop,parentScale:u,childScale:m.times(o),stickyLerp:s,childTop:h,childBottom:p,scaleMultiplier:o},c),r(d({scale:m.times(o),parentScale:u},c)))})(o,i,m,v,p,{stickyLerp:l,fillViewport:a}))};export{A as ParallaxScrollScene,j as StickyScrollScene,b as WebGLImage,y as WebGLText};
+import e,{useMemo as t,useEffect as r,forwardRef as i,useRef as n,useImperativeHandle as o}from"react";import{useThree as s,useFrame as l}from"@react-three/fiber";import{Text as a}from"@react-three/drei";import{useScrollRig as u,useScrollbar as c,useImageAsTexture as m,ScrollScene as h}from"@14islands/r3f-scroll-rig";import{Color as p,Vector2 as f}from"three";function d(){return d=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(e[i]=r[i])}return e},d.apply(this,arguments)}function g(e,t){if(null==e)return{};var r,i,n={},o=Object.keys(e);for(i=0;i<o.length;i++)t.indexOf(r=o[i])>=0||(n[r]=e[r]);return n}const v=["el","children","material","scale","font","fontOffsetY","fontOffsetX","overrideEmissive","color"],y=i=>{let{el:n,children:o,material:l,scale:c,font:m,fontOffsetY:h=0,fontOffsetX:p=0,overrideEmissive:f=!1,color:y}=i,w=g(i,v);const{size:b}=s(),{scaleMultiplier:S}=u(),{textColor:E,fontSize:A,textAlign:x,lineHeight:_,letterSpacing:N}=t(()=>{if(!n.current)return{};const e=window.getComputedStyle(n.current);let t=y||e.color;return!y&&"rgba(0, 0, 0, 0)"===e.color&&n.current.parentElement&&(t=window.getComputedStyle(n.current.parentElement).color),{letterSpacing:(parseFloat(e.letterSpacing)||0)/parseFloat(e.fontSize),lineHeight:(parseFloat(e.lineHeight)||0)/parseFloat(e.fontSize),textColor:t,fontSize:parseFloat(e.fontSize)*S,textAlign:e.textAlign}},[n,b,c,y,S]);r(()=>{l&&f&&(l.emissive=y)},[l,y,f]);let z=0;return"left"===x||"start"===x?z=-.5*c[0]:"right"!==x&&"end"!==x||(z=.5*c[0]),e.createElement(a,d({fontSize:A,maxWidth:c?c[0]:b.width,lineHeight:_,textAlign:x,letterSpacing:N,overflowWrap:"break-word",font:m,color:E,anchorX:x,anchorY:"top",position:[z+A*p,(c?.5*c[1]:.5*b.height)+A*h,0],material:l},w),o)},w=["el","scale","scrollState","vertexShader","fragmentShader","invalidateFrameLoop","widthSegments","heightSegments"],b=i((i,a)=>{let{el:h,scale:v,scrollState:y,vertexShader:b,fragmentShader:S,invalidateFrameLoop:E=!1,widthSegments:A=128,heightSegments:x=128}=i,_=g(i,w);const N=n(null),z=n(null);o(a,()=>z.current);const{invalidate:M,gl:T,size:k}=s(),O=s(e=>e.viewport.dpr),{scroll:V}=c(),{scaleMultiplier:R}=u(),F=m(h),P=t(()=>({u_color:{value:new p("black")},u_time:{value:0},u_pixelRatio:{value:O},u_progress:{value:0},u_visibility:{value:0},u_viewport:{value:0},u_velocity:{value:0},u_res:{value:new f},u_rect:{value:new f},u_size:{value:new f},u_texture:{value:null},u_loaded:{value:!1},u_scaleMultiplier:{value:R}}),[O]);r(()=>{F&&N.current&&(N.current.uniforms.u_texture.value=F,N.current.uniforms.u_size.value.set(F.image.width,F.image.height),N.current.uniforms.u_loaded.value=!0)},[F,T]),r(()=>{N.current&&(N.current.uniforms.u_res.value.set(k.width,k.height),N.current.uniforms.u_rect.value.set(null==v?void 0:v[0],null==v?void 0:v[1]))},[k,v]),l((e,t)=>{y.inViewport&&z.current&&N.current&&N.current.uniforms.u_loaded.value&&(N.current.uniforms.u_time.value+=t,N.current.uniforms.u_rect.value.set(z.current.scale.x,z.current.scale.y),N.current.uniforms.u_velocity.value=V.velocity,N.current.uniforms.u_progress.value=y.progress,N.current.uniforms.u_visibility.value=y.visibility,N.current.uniforms.u_viewport.value=y.viewport,E&&M())});const L=t(()=>[{vertexShader:b,fragmentShader:S}],[b,S]);return e.createElement(e.Fragment,null,e.createElement("mesh",d({ref:z},_),e.createElement("planeGeometry",{attach:"geometry",args:[1,1,A,x]}),e.createElement("shaderMaterial",{ref:N,args:L,transparent:!0,uniforms:P})))}),S=["children","speed"],E=({children:t,scrollState:r,parallax:i})=>{const o=n(null),a=s(e=>e.size),{scaleMultiplier:c}=u();return l(()=>{r.inViewport&&(o.current.position.y=i*(2*r.progress-1)*c*a.height)}),e.createElement("mesh",{ref:o},t)},A=t=>{let{children:r,speed:i=1}=t,n=g(t,S);const o=i-1;return e.createElement(h,d({scissor:!1,inViewportMargin:200*Math.max(0,.5)+50+"%"},n),t=>e.createElement(E,d({parallax:o},t),r(t)))};let x=new Proxy({},{get:function(e,t){return e.hasOwnProperty(t)||(e[t]=z(t)),e[t]}});class _ extends Array{constructor(e,t){if(!(t=O(t)).every(e=>"Number"===R(e)))throw new TypeError("All arguments must be numbers.");if(t.length>1&&t.length!==e)throw new Error("Argument list must be empty, have a single number, or have a length equal to the dimension.");0===t.length&&(t=[0]),1===t.length&&"Number"===R(t[0])&&(t=Array(e).fill(t[0])),e>1?super(...t):(super(1),this[0]=t[0]),Reflect.defineProperty(this,"pop",{value:void 0,enumerable:!1}),Reflect.defineProperty(this,"push",{value:void 0,enumerable:!1}),Reflect.defineProperty(this,"shift",{value:void 0,enumerable:!1}),Reflect.defineProperty(this,"unshift",{value:void 0,enumerable:!1})}get magnitude(){return this.pnorm(2)}div(e){k(e,this.dim,!0),"Number"===R(e)&&(e=new Array(this.dim).fill(e));let t=[];for(let r=0;r<this.length;++r)t[r]=this[r]/e[r];return x[this.dim](t)}minus(e){k(e,this.dim,!0),"Number"===R(e)&&(e=new Array(this.dim).fill(e));let t=[];for(let r=0;r<this.dim;++r)t[r]=this[r]-e[r];return x[this.dim](t)}neg(){return x[this.dim](this.times(-1))}plus(e){k(e,this.dim,!0),"Number"===R(e)&&(e=new Array(this.dim).fill(e));let t=[];for(let r=0;r<this.dim;++r)t[r]=this[r]+e[r];return x[this.dim](t)}pow(e){let t=[];for(let r=0;r<this.dim;++r)t[r]=Math.pow(this[r],e);return x[this.dim](t)}times(e){k(e,this.dim,!0),"Number"===R(e)&&(e=new Array(this.dim).fill(e));let t=[];for(let r=0;r<this.dim;++r)t[r]=this[r]*e[r];return x[this.dim](t)}dot(e){k(e,this.dim);let t=0;for(let r=0;r<this.dim;++r)t+=this[r]*e[r];return t}normalize(){return this.div(this.magnitude)}pnorm(e){let t=0;for(let r=0;r<this.dim;++r)t+=Math.pow(Math.abs(this[r]),e);return Math.pow(t,1/e)}reflect(e){const t=e.normalize();return this.minus(t.times(2*this.dot(t)))}argmax(){const e=this.max();return this.reduce((t,r,i)=>r===e?t.concat([i]):t,[])}argmin(){const e=this.min();return this.reduce((t,r,i)=>r===e?t.concat([i]):t,[])}choose(e){if(!Array.isArray(e))throw new TypeError("Argument must be a list of indices.");if(!e.every(e=>e<this.dim&&V(e.toString())))throw new RangeError("All elements of argument must be valid indices.");let t=[];return e.forEach(e=>t.push(this[e])),x[t.length](t)}copy(){return x[this.dim](this)}equals(e){return e.length===this.dim&&e.every((e,t)=>this[t]===e)}approximatelyEquals(e,t=1e-8){return e.length===this.dim&&e.every((e,r)=>Math.abs(this[r]-e)<t)}max(){return Math.max(...this)}min(){return Math.min(...this)}sum(){return this.reduce((e,t)=>e+t,0)}toArray(){return Array.from(this)}concat(...e){const t=super.concat.apply(this.toArray(),e);return x[t.length](t)}filter(...e){const t=super.filter.apply(this.toArray(),e);return t.length>0?x[t.length](t):t}map(...e){const t=super.map(...e);return t.every(e=>"Number"===R(e))?t:t.toArray()}slice(...e){const t=super.slice.apply(this.toArray(),e);return t.length>0?x[t.length](t):t}splice(...e){let t=this.toArray();if(t.splice(...e),t.length!==this.dim)throw new Error("All removed elements must be replaced.");if(!t.every(e=>"Number"===R(e)))throw new TypeError("All elements must be numbers.");t.forEach((e,t)=>{this[t]=e})}toString(){return this.reduce((e,t,r)=>e+t+(r===this.dim-1?" ":", "),"[ ")+"]"}}const N={set:function(e,t,r){if("length"===t)return!1;if(V(t)){if(Number(t)>=e.dim)throw new RangeError("Vector may not have more elements than dimension.");if("Number"!==R(r))throw new TypeError("Vectors may only contain numbers.");return e[t]=r,!0}const i=T(t.toString());return!!(e.dim<=4&&i)&&(function(e,t,r,i){if(1===t.length){if("Number"!==R(i))throw new TypeError("Must set to a number");return void(e[r[t]]=i)}if(!Array.isArray(i))throw new TypeError("Right-hand side must be an array.");if(t.length!==i.length)throw new TypeError("Right-hand side must have matching length.");if(!i.every(e=>"Number"===R(e)))throw new TypeError("All new values must be numbers.");if(t.split("").some(t=>r[t]>=e.dim))return;let n=!0;for(let e=0,r={};e<t.length;++e){if(r.hasOwnProperty(t[e])){n=!1;break}r[t[e]]=!0}if(!n)throw new SyntaxError("Swizzle assignment does not allow symbols to be repeated.");t.split("").map(e=>r[e]).forEach((t,r)=>{e[t]=i[r]})}(e,t.toString(),i,r),!0)},get:function(e,t){const r=T(t.toString());return e.dim<=4&&r?function(e,t,r){const i=t.length;if(1===i)return e[r[t]];let n=t.split("").reduce((t,i)=>{let n=r[i];return t&&n<e.dim?t.concat([e[n]]):void 0},[]);return n?new x[i](...n):void 0}(e,t,r):e[t]}};function z(e){if(!((e=Number(e))in x)){if(isNaN(e))throw new TypeError("Dimension must be coercible to a number.");if(e<=0)throw new RangeError("Dimension must be positive.");if(!Number.isInteger(e))throw new RangeError("Dimension must be positive.");let t="vec"+e,r={[t]:class extends _{constructor(...t){if(1===t.length&&t[0]instanceof _){if(t[0].dim>e)throw new TypeError("Cannot demote vectors.");t=function(e,t){return[...Array(t)].map((t,r)=>r<e.length?e[r]:0)}(t[0].toArray(),e)}super(e,t),Reflect.defineProperty(this,"dim",{value:e,writable:!1,enumerable:!1})}}}[t];x[e]=function(...e){let t=new r(...e);return Object.preventExtensions(t),new Proxy(t,N)}}return x[e]}const M=[{x:0,y:1,z:2,w:3},{r:0,g:1,b:2,a:3},{s:0,t:1,p:2,q:3}];function T(e){return M.find(t=>e.split("").every(e=>e in t))}function k(e,t,r=!1){if(!(r&&"Number"===R(e)||e.length&&e.length===t))throw new TypeError(`Invalid argument. Input must have matching dimension${r?"or be a scalar":""}.`)}function O(e){return e instanceof Array&&1===e.length&&e[0]instanceof Array?O(e[0]):e}function V(e){return!isNaN(e)&&Number(e).toString()===e&&Number.isInteger(Number(e))&&Number(e)>=0}function R(e){return Object.prototype.toString.call(e).slice(8,-1)}var F={getVecType:z,isVec:function(e){return e instanceof _},vec2:x[2],vec3:x[3],vec4:x[4],add:function(...e){const t=e[0].dim;if(!e.every(e=>e.dim===t))throw new TypeError("All vectors must have the same dimension.");return e.reduce((e,t)=>e.plus(t),x[t]())},multiply:function(...e){const t=e[0].dim;if(!e.every(e=>e.dim===t))throw new TypeError("All vectors must have the same dimension.");return e.reduce((e,t)=>e.times(t),x[t](1))},lerp:function(e,t,r){if(e.dim!==t.dim)throw new TypeError("Vectors must have the same dimension.");return r=r<0?0:r>1?1:r,e.plus(t.minus(e).times(r))},slerp:function(e,t,r){if(e.dim!==t.dim)throw new TypeError("Vectors must have the same dimension.");r=r<0?0:r>1?1:r;let i=e.normalize().dot(t.normalize());i=i<-1?-1:i>1?1:i;const n=Math.acos(i)*r,o=t.minus(e.times(i)).normalize(),s=e.magnitude+(t.magnitude-e.magnitude)*r;return e.times(Math.cos(n)).plus(o.times(Math.sin(n))).normalize().times(s)}};const P=["scale"],L=["children","track","stickyLerp","fillViewport"],C=({children:t,childTop:r,childBottom:i,scrollState:o,parentScale:a,childScale:u,scaleMultiplier:c,priority:m,stickyLerp:h=1,offsetTop:p=0})=>{const f=n(null),d=s(e=>e.size);return l((e,t)=>{if(!o.inViewport)return;const n=.5*a[1]-.5*u[1]-p*c;let s=f.current.position.y;s=o.viewport+(r-p)/d.height<1?n:o.visibility-i/a[1]*c<1?-r*c+n-(o.viewport-1)*d.height*c+p*c:.5*-a[1]+.5*u[1],f.current.position.y=function(e,t,r,i,n=60){return o=t,e*(1-(s=void 0===i?r:1-Math.pow(1-r,i/(1/n))))+o*s;var o,s}(f.current.position.y,s,h,t)},m),e.createElement("group",{ref:f},t)},j=r=>{let{children:i,track:o,stickyLerp:l,fillViewport:a}=r,c=g(r,L);const m=s(e=>e.size),{scaleMultiplier:p}=u(),f=n(o.current),v=t(()=>{const e=getComputedStyle(o.current);return"sticky"===e.position?(f.current=o.current.parentElement,"static"===getComputedStyle(f.current).position&&console.error("StickyScrollScene: parent of position:sticky needs to be position:relative or position:absolute (currently set to position:static)")):console.error("StickyScrollScene: tracked element is not position:sticky"),e},[o]);return e.createElement(h,d({track:f},c),((t,r,i,o,s,{stickyLerp:l,fillViewport:a})=>u=>{let{scale:c}=u,m=g(u,P),h=F.vec3(parseFloat(o.width),parseFloat(o.height),1),p=parseFloat(o.top),f=i.height-p-h[1];a&&(h=F.vec3(i.width,i.height,1),p=0,f=0);const v=n(t.current.offsetTop).current;return e.createElement(C,d({offsetTop:v,parentScale:c,childScale:h.times(s),stickyLerp:l,childTop:p,childBottom:f,scaleMultiplier:s},m),r(d({scale:h.times(s),parentScale:c},m)))})(o,i,m,v,p,{stickyLerp:l,fillViewport:a}))};export{A as ParallaxScrollScene,j as StickyScrollScene,b as WebGLImage,y as WebGLText};
 //# sourceMappingURL=powerups.modern.js.map
diff --git a/dist/powerups.modern.js.map b/dist/powerups.modern.js.map
index 9716b0745fa2fb407eae4762dbbd053d86a830a0..af8445ec22e13aafa1fb6442996eb3bb3fedf00d 100644
--- a/dist/powerups.modern.js.map
+++ b/dist/powerups.modern.js.map
@@ -1 +1 @@
-{"version":3,"file":"powerups.modern.js","sources":["../powerups/WebGLText.tsx","../powerups/WebGLImage.tsx","../powerups/ParallaxScrollScene.tsx","../../node_modules/vecn/src/index.js","../powerups/StickyScrollScene.tsx","../../node_modules/@14islands/lerp/index.js","../../node_modules/lerp/index.js"],"sourcesContent":["import React, { useMemo, useEffect, ReactNode, MutableRefObject } from 'react'\nimport { Color, Material } from 'three'\nimport { useThree } from '@react-three/fiber'\nimport { Text } from '@react-three/drei'\n\nimport { useScrollRig } from '@14islands/r3f-scroll-rig'\n\n/**\n * Returns a WebGL Troika text mesh styled as the source DOM element\n */\n\ninterface WebGLTextProps {\n  el: MutableRefObject<HTMLElement>\n  children?: ReactNode\n  material?: Material\n  scale?: any\n  font?: string\n  fontOffsetY?: number\n  fontOffsetX?: number\n  overrideEmissive?: boolean\n  color?: string\n}\n\nexport const WebGLText = ({\n  el,\n  children,\n  material,\n  scale,\n  font,\n  fontOffsetY = 0,\n  fontOffsetX = 0,\n  overrideEmissive = false,\n  color,\n  ...props\n}: WebGLTextProps) => {\n  const { size } = useThree()\n  const { scaleMultiplier } = useScrollRig()\n\n  const { textColor, fontSize, textAlign, lineHeight, letterSpacing } = useMemo(() => {\n    if (!el.current) return {}\n    const cs = window.getComputedStyle(el.current)\n\n    // get color from parent if set to transparent\n    let textColor = color || cs.color\n    if (!color && cs.color === 'rgba(0, 0, 0, 0)' && el.current.parentElement) {\n      textColor = window.getComputedStyle(el.current.parentElement).color\n    }\n\n    // font size relative letter spacing\n    const letterSpacing = (parseFloat(cs.letterSpacing) || 0) / parseFloat(cs.fontSize)\n    const lineHeight = (parseFloat(cs.lineHeight) || 0) / parseFloat(cs.fontSize)\n\n    return {\n      letterSpacing,\n      lineHeight,\n      textColor,\n      fontSize: parseFloat(cs.fontSize) * scaleMultiplier,\n      textAlign: cs.textAlign,\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [el, size, scale, color, scaleMultiplier]) // recalc on resize\n\n  useEffect(() => {\n    if (material && overrideEmissive) {\n      // @ts-ignore\n      material.emissive = color\n    }\n  }, [material, color, overrideEmissive])\n\n  let xOffset = 0\n  if (textAlign === 'left' || textAlign === 'start') {\n    xOffset = scale[0] * -0.5\n  } else if (textAlign === 'right' || textAlign === 'end') {\n    xOffset = scale[0] * 0.5\n  }\n\n  const yOffset = scale ? scale[1] * 0.5 : size.height * 0.5\n\n  return (\n    <Text\n      fontSize={fontSize}\n      maxWidth={scale ? scale[0] : size.width}\n      lineHeight={lineHeight}\n      // @ts-ignore\n      textAlign={textAlign}\n      letterSpacing={letterSpacing}\n      overflowWrap=\"break-word\"\n      font={font}\n      color={textColor}\n      // @ts-ignore\n      anchorX={textAlign}\n      anchorY=\"top\" // so text moves down if row breaks\n      // @ts-ignore\n      position={[xOffset + fontSize * fontOffsetX, yOffset + fontSize * fontOffsetY, 0]} // font specific\n      material={material}\n      {...props}\n    >\n      {children}\n    </Text>\n  )\n}\n","import React, {\n  useRef,\n  useMemo,\n  useEffect,\n  forwardRef,\n  MutableRefObject,\n  ForwardedRef,\n  useImperativeHandle,\n} from 'react'\nimport { Color, Vector2, ShaderMaterial, Mesh, ShaderMaterialParameters } from 'three'\nimport { useFrame, useThree } from '@react-three/fiber'\n\nimport { useScrollRig, useImageAsTexture, useScrollbar } from '@14islands/r3f-scroll-rig'\n\ninterface WebGLImageProps {\n  el: MutableRefObject<HTMLImageElement>\n  scale?: any\n  scrollState?: any\n  vertexShader?: string\n  fragmentShader?: string\n  invalidateFrameLoop: boolean\n  widthSegments?: number\n  heightSegments?: number\n}\n\nexport const WebGLImage = forwardRef(\n  (\n    {\n      el,\n      scale,\n      scrollState,\n      vertexShader,\n      fragmentShader,\n      invalidateFrameLoop = false,\n      widthSegments = 128,\n      heightSegments = 128,\n      ...props\n    }: WebGLImageProps,\n    ref: ForwardedRef<Mesh>\n  ) => {\n    const material = useRef<ShaderMaterial>(null!)\n    const mesh = useRef<Mesh>(null!)\n    useImperativeHandle(ref, () => mesh.current)\n\n    const { invalidate, gl, size } = useThree()\n    const pixelRatio = useThree((s) => s.viewport.dpr)\n    const { scroll } = useScrollbar()\n    const { scaleMultiplier } = useScrollRig()\n\n    const texture = useImageAsTexture(el)\n\n    const uniforms = useMemo(() => {\n      return {\n        u_color: { value: new Color('black') },\n        u_time: { value: 0 },\n        u_pixelRatio: { value: pixelRatio },\n        u_progress: { value: 0 },\n        u_visibility: { value: 0 },\n        u_viewport: { value: 0 },\n        u_velocity: { value: 0 }, // scroll speed\n        u_res: { value: new Vector2() }, // screen dimensions\n        u_rect: { value: new Vector2() }, // DOM el dimensions\n        u_size: { value: new Vector2() }, // Texture dimensions\n        u_texture: { value: null },\n        u_loaded: { value: false },\n        u_scaleMultiplier: { value: scaleMultiplier },\n      }\n    }, [pixelRatio])\n\n    // Fade in when texture loaded\n    useEffect(() => {\n      if (!texture) return\n      if (!material.current) return\n      material.current.uniforms.u_texture.value = texture\n      material.current.uniforms.u_size.value.set(texture.image.width, texture.image.height)\n      material.current.uniforms.u_loaded.value = true\n    }, [texture, gl])\n\n    useEffect(() => {\n      if (!material.current) return\n      material.current.uniforms.u_res.value.set(size.width, size.height)\n      material.current.uniforms.u_rect.value.set(scale?.[0], scale?.[1])\n    }, [size, scale])\n\n    useFrame((_, delta) => {\n      if (!scrollState.inViewport || !mesh.current || !material.current) return\n\n      if (!material.current.uniforms.u_loaded.value) return\n\n      material.current.uniforms.u_time.value += delta\n\n      // update scale while animating too\n      material.current.uniforms.u_rect.value.set(mesh.current.scale.x, mesh.current.scale.y)\n\n      // px velocity\n      material.current.uniforms.u_velocity.value = scroll.velocity\n\n      // percent of total visible distance that was scrolled (0 = just outside bottom of screen, 1 = just outside top of screen)\n      material.current.uniforms.u_progress.value = scrollState.progress\n\n      // percent of item height in view\n      material.current.uniforms.u_visibility.value = scrollState.visibility\n      // percent of window height scrolled since visible\n      material.current.uniforms.u_viewport.value = scrollState.viewport\n\n      if (invalidateFrameLoop) invalidate()\n    })\n\n    const args = useMemo(\n      () => [\n        {\n          vertexShader,\n          fragmentShader,\n        },\n      ],\n      [vertexShader, fragmentShader]\n    )\n\n    return (\n      <>\n        <mesh ref={mesh} {...props}>\n          <planeGeometry attach=\"geometry\" args={[1, 1, widthSegments, heightSegments]} />\n          <shaderMaterial\n            ref={material}\n            args={args as [ShaderMaterialParameters]}\n            transparent={true}\n            uniforms={uniforms}\n          />\n        </mesh>\n      </>\n    )\n  }\n)\n","import React, { useRef } from 'react'\nimport { useFrame, useThree } from '@react-three/fiber'\nimport { Mesh } from 'three'\n\nimport { ScrollScene, useScrollRig } from '@14islands/r3f-scroll-rig'\n\n// Parallax group inside ScrollScene\nconst ParallaxGroup = ({ children, scrollState, parallax }: any) => {\n  const mesh = useRef<Mesh>(null!)\n  const size = useThree((s) => s.size)\n  const { scaleMultiplier } = useScrollRig()\n\n  useFrame(() => {\n    if (!scrollState.inViewport) return\n    const parallaxProgress = scrollState.progress * 2 - 1\n    mesh.current.position.y = parallax * parallaxProgress * scaleMultiplier * size.height\n  })\n\n  return <mesh ref={mesh}>{children}</mesh>\n}\n\n/* Speed=1 is no parallax */\nexport const ParallaxScrollScene = ({ children, speed = 1, ...props }: any) => {\n  const extraMargin = 50 // add 50vh extra margin to avoid aggressive clipping\n  const parallaxAmount = speed - 1\n  return (\n    // @ts-ignore\n    <ScrollScene scissor={false} inViewportMargin={`${Math.max(0, 1 - 0.5) * 200 + extraMargin}%`} {...props}>\n      {(props) => (\n        <ParallaxGroup parallax={parallaxAmount} {...props}>\n          {children(props)}\n        </ParallaxGroup>\n      )}\n    </ScrollScene>\n  )\n}\n","/**\n * An object for memoizing vecType functions.\n * @type {Object}\n * @private\n */\nlet vecTypes = (function () {\n  const handler = {\n    get: function (obj, prop) {\n      if (!obj.hasOwnProperty(prop)) {\n        obj[prop] = getVecType(prop)\n      }\n      return obj[prop]\n    }\n  }\n\n  return new Proxy({}, handler)\n})()\n\n/**\n * A class for fixed-size vectors of numbers.\n * @extends Array\n */\nclass vecn extends Array {\n  /**\n   * Creates a vecn of the specified dimension. This should never be called\n   * by the user (as if this were an abstract class).\n   * @param {number} dimension The dimension of this vector.\n   * @param {number[]} [args=[]] The numbers to be put in the vector.\n   */\n  constructor (dimension, args) {\n    args = flattenOuter(args)\n\n    if (!args.every((x) => type(x) === 'Number')) {\n      throw new TypeError('All arguments must be numbers.')\n    }\n    if (args.length > 1 && args.length !== dimension) {\n      throw new Error('Argument list must be empty, have a single number, or have a length equal to the dimension.')\n    }\n\n    if (args.length === 0) {\n      args = [0]\n    }\n    if (args.length === 1 && type(args[0]) === 'Number') {\n      args = Array(dimension).fill(args[0])\n    }\n\n    if (dimension > 1) {\n      super(...args)\n    } else {\n      super(1)\n      this[0] = args[0]\n    }\n\n    Reflect.defineProperty(this, 'pop', {\n      value: undefined,\n      enumerable: false\n    })\n    Reflect.defineProperty(this, 'push', {\n      value: undefined,\n      enumerable: false\n    })\n    Reflect.defineProperty(this, 'shift', {\n      value: undefined,\n      enumerable: false\n    })\n    Reflect.defineProperty(this, 'unshift', {\n      value: undefined,\n      enumerable: false\n    })\n  }\n\n  /**\n   * The L2 norm (Euclidian norm) of the vector.\n   * @type {number}\n   */\n  get magnitude () {\n    return this.pnorm(2)\n  }\n\n  // --------------------------------------------------------------------------\n  //   Arithmetic\n\n  /**\n   * Returns a vector where this is divided by v componentwise. If v is\n   * a single number, the vector is scaled by 1/v.\n   * @param {number|number[]} v The value to multiply with.\n   *\n   * @returns {vecn} A new vector with the divided components.\n   */\n  div (v) {\n    checkCompatibility(v, this.dim, true)\n    if (type(v) === 'Number') {\n      v = (new Array(this.dim)).fill(v)\n    }\n\n    let result = []\n    for (let i = 0; i < this.length; ++i) {\n      result[i] = this[i] / v[i]\n    }\n    return vecTypes[this.dim](result)\n  }\n\n  /**\n   * Returns a vector where v is subtracted from the components of this\n   * vector. If v is a single number, it is subtracted to each component. If v\n   * is a vector, the vectors are combined componentwise.\n   * @param {number|number[]} v The value to subtract from this vector.\n   *\n   * @returns {vecn} A new vector with the combined components.\n   */\n  minus (v) {\n    checkCompatibility(v, this.dim, true)\n    if (type(v) === 'Number') {\n      v = (new Array(this.dim)).fill(v)\n    }\n\n    let result = []\n    for (let i = 0; i < this.dim; ++i) {\n      result[i] = this[i] - v[i]\n    }\n    return vecTypes[this.dim](result)\n  }\n\n  /**\n   * Negates each element in this vector.\n   * @returns {vecn} A new vector where all elements are negated.\n   */\n  neg () {\n    return vecTypes[this.dim](this.times(-1))\n  }\n\n  /**\n   * Returns a vector where v is added to the components of this vector. If v\n   * is a single number, it is added to each component. If v is a vector, the\n   * vectors are added componentwise.\n   * @param {number|number[]} v The value to add to this vector.\n   *\n   * @returns {vecn} A new vector with the summed components.\n   */\n  plus (v) {\n    checkCompatibility(v, this.dim, true)\n    if (type(v) === 'Number') {\n      v = (new Array(this.dim)).fill(v)\n    }\n\n    let result = []\n    for (let i = 0; i < this.dim; ++i) {\n      result[i] = this[i] + v[i]\n    }\n    return vecTypes[this.dim](result)\n  }\n\n  /**\n   * Returns a vector where each component of this was raised to a power p.\n   * @param {number} p The power to raise each component by.\n   *\n   * @returns {vecn} A new vector with the exponentiated components.\n   */\n  pow (p) {\n    let result = []\n    for (let i = 0; i < this.dim; ++i) {\n      result[i] = Math.pow(this[i], p)\n    }\n    return vecTypes[this.dim](result)\n  }\n\n  /**\n   * Returns a vector where v and this are multiplied componentwise. If v is\n   * a single number, the vector is scaled by v.\n   * @param {number|number[]} v The value to multiply with.\n   *\n   * @returns {vecn} A new vector with the multiplied components.\n   */\n  times (v) {\n    checkCompatibility(v, this.dim, true)\n    if (type(v) === 'Number') {\n      v = (new Array(this.dim)).fill(v)\n    }\n\n    let result = []\n    for (let i = 0; i < this.dim; ++i) {\n      result[i] = this[i] * v[i]\n    }\n    return vecTypes[this.dim](result)\n  }\n\n  // --------------------------------------------------------------------------\n  //   Vector Operations\n\n  /**\n   * Dot product of two vectors.\n   * @param {number[]} v The vector to dot with this one.\n   *\n   * @returns {number} The dot product between this and v.\n   */\n  dot (v) {\n    checkCompatibility(v, this.dim)\n\n    let result = 0\n    for (let i = 0; i < this.dim; ++i) {\n      result += this[i] * v[i]\n    }\n    return result\n  }\n\n  /**\n   * Scales this vector to a magnitude of 1.\n   *\n   * @returns {vecn} A new vector with scaled components.\n   */\n  normalize () {\n    return this.div(this.magnitude)\n  }\n\n  /**\n   * Evaluates the p-norm (or lp-norm) of this vector.\n   * @param {number} p The p-value to evaluate.\n   *\n   * @returns {number} The norm of this vector.\n   */\n  pnorm (p) {\n    let result = 0\n    for (let i = 0; i < this.dim; ++i) {\n      result += Math.pow(Math.abs(this[i]), p)\n    }\n    return Math.pow(result, 1 / p)\n  }\n\n  /**\n   * Reflects this vector across the provided vector. The normal can be imagined\n   * as a surface normal or as describing a hyperpalane.\n   * @param {number[]} normal A vector describing the hyperplane to reflect off of.\n   *\n   * @returns {vecn} The reflected vector.\n   */\n  reflect (normal) {\n    const n = normal.normalize()\n    return this.minus(n.times(2 * this.dot(n)))\n  }\n\n  // --------------------------------------------------------------------------\n  //   Extras\n\n  /**\n   * Finds the indices of the max value in this vector.\n   *\n   * @returns {number[]} An array of indices corresponding to the max values.\n   */\n  argmax () {\n    const maxVal = this.max()\n    return this.reduce((acc, x, i) => x === maxVal ? acc.concat([i]) : acc, [])\n  }\n\n  /**\n   * Finds the indices of the min value in this vector.\n   *\n   * @returns {number[]} An array of indices corresponding to the min values.\n   */\n  argmin () {\n    const minVal = this.min()\n    return this.reduce((acc, x, i) => x === minVal ? acc.concat([i]) : acc, [])\n  }\n\n  /**\n   * Creates a new vector from the provided indices of this one. Basically\n   * equivalent to swizzling.\n   * @param {number[]} indices The indices to select into a new vector.\n   *\n   * @returns {vecn} A new vector from the provided indices.\n   */\n  choose (indices) {\n    if (!Array.isArray(indices)) {\n      throw new TypeError('Argument must be a list of indices.')\n    }\n    if (!indices.every((i) => i < this.dim && isIndex(i.toString()))) {\n      throw new RangeError('All elements of argument must be valid indices.')\n    }\n\n    let v = []\n    indices.forEach((i) => v.push(this[i]))\n    return vecTypes[v.length](v)\n  }\n\n  /**\n   * Creates a duplicate of this vector. Same as passing this vector through\n   * the factory that created it.\n   *\n   * @returns {vecn} A deep copy of this vector.\n   */\n  copy () {\n    return vecTypes[this.dim](this)\n  }\n\n  /**\n   * Returns whether every element in each vector is equal.\n   * @param {number[]} v A vector to test against.\n   *\n   * @returns {boolean} True if both vectors have the same dimension and values.\n   */\n  equals (v) {\n    return v.length === this.dim && v.every((x, i) => this[i] === x)\n  }\n\n  /**\n   * Returns whether every element in each vector is approximately equal.\n   * @param {number[]} v A vector to test against.\n   * @param {number} epsilon The largest meaningful difference between two values.\n   *\n   * @returns {boolean} True if both vectors have the same dimension and the\n   * distance between each number is less than epsilon.\n   */\n  approximatelyEquals (v, epsilon = 0.00000001) {\n    return v.length === this.dim && v.every((x, i) => Math.abs(this[i] - x) < epsilon)\n  }\n\n  /**\n   * Returns the max value of this vector.\n   *\n   * @returns {number} The max value of this vector.\n   */\n  max () {\n    return Math.max(...this)\n  }\n\n  /**\n   * Returns the min value of this vector.\n   *\n   * @returns {number} The min value of this vector.\n   */\n  min () {\n    return Math.min(...this)\n  }\n\n  /**\n   * Sums the components of this vector.\n   *\n   * @returns {number} The sum of the components of this vector.\n   */\n  sum () {\n    return this.reduce((acc, x) => acc + x, 0)\n  }\n\n  /**\n   * Converts this vector into an Array.\n   *\n   * @returns {number[]} An array of the contents of this vector.\n   */\n  toArray () {\n    return Array.from(this)\n  }\n\n  // --------------------------------------------------------------------------\n  //   Array Overrides\n\n  /**\n   * Same as Array.prototype.concat, but return value is of a new vecType.\n   *\n   * @returns {vecn}\n   */\n  concat (...args) {\n    const result = super.concat.apply(this.toArray(), args)\n    return vecTypes[result.length](result)\n  }\n\n  /**\n   * Same as Array.prototype.filter, but returns an Array if the result has 0\n   * entries.\n   *\n   * @returns {vecn|number[]}\n   */\n  filter (...args) {\n    const result = super.filter.apply(this.toArray(), args)\n    if (result.length > 0) {\n      return vecTypes[result.length](result)\n    }\n    return result\n  }\n\n  /**\n   * Same as Array.prototype.map, but returns an Array if the result contains\n   * non-numbers.\n   *\n   * @returns {vecn|Array}\n   */\n  map (...args) {\n    const result = super.map(...args)\n    if (result.every((x) => type(x) === 'Number')) {\n      return result\n    }\n    return result.toArray()\n  }\n\n  /**\n   * Same as Array.prototype.slice, but returns an Array if the result has 0\n   * entries.\n   */\n  slice (...args) {\n    const result = super.slice.apply(this.toArray(), args)\n    if (result.length > 0) {\n      return vecTypes[result.length](result)\n    }\n    return result\n  }\n\n  /**\n   * A restrictive version of the Array.prototype.splice that requires all\n   * removed elements to be replaced.\n   */\n  splice (...args) {\n    let test = this.toArray()\n    test.splice(...args)\n\n    if (test.length !== this.dim) {\n      throw new Error('All removed elements must be replaced.')\n    }\n    if (!test.every((x) => type(x) === 'Number')) {\n      throw new TypeError('All elements must be numbers.')\n    }\n\n    test.forEach((x, i) => { this[i] = x })\n  }\n\n  toString () {\n    return this.reduce((s, x, i) => {\n      return s + x + (i === this.dim - 1 ? ' ' : ', ')\n    }, '[ ') + ']'\n  }\n}\n\n// --------------------------------------------------------------------------\n//   General Tools\n\n/**\n * Adds an arbitrary number of vectors together. All vectors must be of the same\n * dimension.\n * @param {...vecn} vecs Vectors to add together.\n *\n * @returns {vecn} The sum of all the provided vectors.\n */\nfunction add (...vecs) {\n  const dim = vecs[0].dim\n  if (!vecs.every((v) => v.dim === dim)) {\n    throw new TypeError('All vectors must have the same dimension.')\n  }\n  return vecs.reduce((acc, v) => acc.plus(v), vecTypes[dim]())\n}\n\n/**\n * The validator to be used in the proxy for all vec objects. Catches swizzling\n * properties, makes sure assignment only works for indices, and disallows\n * non-numerical assignments. Used in getVecType.\n * @constant\n * @type {Object}\n * @private\n */\nconst validator = {\n  set: function (obj, prop, value) {\n    if (prop === 'length') {\n      return false\n    }\n    if (isIndex(prop)) {\n      if (Number(prop) >= obj.dim) {\n        throw new RangeError('Vector may not have more elements than dimension.')\n      } else if (type(value) !== 'Number') {\n        throw new TypeError('Vectors may only contain numbers.')\n      } else {\n        obj[prop] = value\n        return true\n      }\n    }\n\n    const swizzleSymbolMap = getSwizzleSymbolMap(prop.toString())\n    if (obj.dim <= 4 && swizzleSymbolMap) {\n      swizzleSet(obj, prop.toString(), swizzleSymbolMap, value)\n      return true\n    }\n\n    return false\n  },\n  get: function (obj, prop) {\n    const swizzleSymbolMap = getSwizzleSymbolMap(prop.toString())\n    if (obj.dim <= 4 && swizzleSymbolMap) {\n      return swizzleGet(obj, prop, swizzleSymbolMap)\n    }\n\n    return obj[prop]\n  }\n}\n\n/**\n * Returns a factory function for vectors of the specified dimension.\n * @param {number} dim The dimension of the new vector type.\n *\n * @returns {Function} A factory (not a constructor) for creating new vecs.\n */\nfunction getVecType (dim) {\n  dim = Number(dim)\n\n  if (!(dim in vecTypes)) {\n    if (isNaN(dim)) throw new TypeError('Dimension must be coercible to a number.')\n    if (dim <= 0) throw new RangeError('Dimension must be positive.')\n    if (!Number.isInteger(dim)) throw new RangeError('Dimension must be positive.')\n\n    // Doing a little bit of exploiting ES6 to dynamically name the class\n    let classname = 'vec' + dim\n    let VecType = ({[classname]: class extends vecn {\n      constructor (...args) {\n        if (args.length === 1 && args[0] instanceof vecn) {\n          if (args[0].dim > dim) {\n            throw new TypeError('Cannot demote vectors.')\n          }\n          args = promoteArrayDimension(args[0].toArray(), dim)\n        }\n        super(dim, args)\n        Reflect.defineProperty(this, 'dim', {\n          value: dim,\n          writable: false,\n          enumerable: false\n        })\n      }\n    }})[classname]\n\n    let factory = function factory (...args) {\n      let target = new VecType(...args)\n      Object.preventExtensions(target)\n      return new Proxy(target, validator)\n    }\n    vecTypes[dim] = factory\n  }\n\n  return vecTypes[dim]\n}\n\n/**\n * The correct function for determining whether an object is a vecn.\n * @param {*} v The object in question.\n *\n * @returns {boolean} True if the object is an instance of vecn.\n */\nfunction isVec (v) {\n  return v instanceof vecn\n}\n\n/**\n * Linearly interpolates between two vectors.\n * @param {vecn} v1 The starting vector.\n * @param {vecn} v2 The ending vector.\n * @param {number} t The interpolant, which is clamped to the inteval [0, 1].\n *\n * @returns {vecn} The interpolated vector.\n */\nfunction lerp (v1, v2, t) {\n  if (v1.dim !== v2.dim) throw new TypeError('Vectors must have the same dimension.')\n  t = t < 0 ? 0 : (t > 1 ? 1 : t)\n  return v1.plus(v2.minus(v1).times(t))\n}\n\n/**\n * Multiplies an arbitrary number of vectors together. All vectors must be of the same\n * dimension.\n * @param {...vecn} vecs Vectors to multiply together.\n *\n * @returns {vecn} The product of all the provided vectors.\n */\nfunction multiply (...vecs) {\n  const dim = vecs[0].dim\n  if (!vecs.every((v) => v.dim === dim)) throw new TypeError('All vectors must have the same dimension.')\n  return vecs.reduce((acc, v) => acc.times(v), vecTypes[dim](1))\n}\n\n/**\n * Spherically interpolates between two vectors.\n * @param {vecn} v1 The starting vector.\n * @param {vecn} v2 The ending vector.\n * @param {number} t The interpolant, which is clamped to the inteval [0, 1].\n *\n * @returns {vecn} The interpolated vector.\n */\nfunction slerp (v1, v2, t) {\n  if (v1.dim !== v2.dim) throw new TypeError('Vectors must have the same dimension.')\n\n  t = t < 0 ? 0 : (t > 1 ? 1 : t)\n  let dot = v1.normalize().dot(v2.normalize())\n  dot = dot < -1 ? -1 : (dot > 1 ? 1 : dot)\n  const theta = Math.acos(dot) * t\n  const relative = v2.minus(v1.times(dot)).normalize()\n  const magnitude = v1.magnitude + ((v2.magnitude - v1.magnitude) * t)\n  return v1.times(Math.cos(theta)).plus(relative.times(Math.sin(theta)))\n    .normalize().times(magnitude)\n}\n\n// --------------------------------------------------------------------------\n//   Swizzling\n\n/**\n * The index corresponding to common names for indexing vectors.\n * @constant\n * @type {Object}\n * @private\n */\nconst namedIndices = [\n  {x: 0, y: 1, z: 2, w: 3},\n  {r: 0, g: 1, b: 2, a: 3},\n  {s: 0, t: 1, p: 2, q: 3}\n]\n\n/**\n * Gets the set of symbols corresponding to indices used for swizzling.\n * @private\n * @param {string} s The string used as a property to swizzle.\n *\n * @returns {Object} A map from characters to indices.\n */\nfunction getSwizzleSymbolMap (s) {\n  return namedIndices.find((map) => {\n    return s.split('').every((c) => c in map)\n  })\n}\n\n/**\n * Creates a new vector from the named indices given by swizzling.\n * @private\n * @param {vecn} v The vector to pull data from. The dimension is assumed to be\n * 2, 3, or 4, but this isn't enforced here.\n * @param {string} s The property being used to swizzle (e.g. 'xxy' or 'z').\n * @param {Object} set A map from characters to indices (assumed to be valid).\n *\n * @returns {undefined|number|vecn} Either undefined (if s isn't a valid swizzle\n * string), a number (if s has a length of 1), or a vecn where the values have\n * been rearranged according to the order given in s.\n */\nfunction swizzleGet (v, s, set) {\n  const newDim = s.length\n\n  if (newDim === 1) {\n    return v[set[s]]\n  }\n\n  let values = s.split('').reduce((acc, x) => {\n    let i = set[x]\n    return acc && i < v.dim ? acc.concat([v[i]]) : undefined\n  }, [])\n  return values ? new vecTypes[newDim](...values) : undefined\n}\n\n/**\n * Assigns the indexed values in v to the values in newVals in the order they\n * are described in in s.\n * @private\n * @param {vecn} v The starting vector.\n * @param {string} s The property being used to swizzle (e.g. 'xyz' or 'xz').\n * @param {Object} map A map from characters to indices (assumed to be valid).\n * @param {number|number[]} newVals The right hand side of the assignment\n *\n * @returns {vecn} A copy of v with the correct elements replaced.\n */\nfunction swizzleSet (v, s, map, newVals) {\n  if (s.length === 1) {\n    if (type(newVals) !== 'Number') {\n      throw new TypeError('Must set to a number')\n    }\n    v[map[s]] = newVals\n    return\n  }\n\n  if (!Array.isArray(newVals)) throw new TypeError('Right-hand side must be an array.')\n  if (s.length !== newVals.length) throw new TypeError('Right-hand side must have matching length.')\n  if (!newVals.every((item) => type(item) === 'Number')) throw new TypeError('All new values must be numbers.')\n\n  if (s.split('').some((c) => map[c] >= v.dim)) {\n    return\n  }\n\n  let valid = true\n  for (let i = 0, unique = {}; i < s.length; ++i) {\n    if (unique.hasOwnProperty(s[i])) {\n      valid = false\n      break\n    }\n    unique[s[i]] = true\n  }\n  if (!valid) throw new SyntaxError('Swizzle assignment does not allow symbols to be repeated.')\n\n  s.split('').map((c) => map[c]).forEach((index, i) => { v[index] = newVals[i] })\n}\n\n// --------------------------------------------------------------------------\n//   Helpers\n\n/**\n * Checks whether something is valid to do vector operations with and throws\n * a TypeError if not.\n * @private\n * @param {*} o An object to check.\n * @param {number} dim The dimension to check against.\n * @param {boolean} [numberValid=false] Whether scalars are compatible for the operation.\n */\nfunction checkCompatibility (o, dim, numberValid = false) {\n  if (numberValid && type(o) === 'Number') {\n    return\n  } else if (o.length && o.length === dim) {\n    return\n  }\n  throw new TypeError(`Invalid argument. Input must have matching dimension${numberValid ? 'or be a scalar' : ''}.`)\n}\n\n/**\n * Removes outer arrays and returns a reference to the innermost array. For\n * example, [[1, 2]] becomes [1, 2]. [[[['a'], true]]] becomes [['a'], true].\n * @private\n * @param {Array} arr The array to flatten.\n *\n * @returns {Array} A reference to the innermost array in arr.\n */\nfunction flattenOuter (arr) {\n  if (!(arr instanceof Array) || arr.length !== 1) {\n    return arr\n  }\n  if (arr[0] instanceof Array) {\n    return flattenOuter(arr[0])\n  }\n  return arr\n}\n\n/**\n * Checks whether a provided string can be used as a valid index into an array.\n * @private\n * @param {string} n A string representation of the number in question.\n *\n * @returns {boolean} True if n can be used to index an array.\n */\nfunction isIndex (n) {\n  return !isNaN(n) &&\n         Number(n).toString() === n &&\n         Number.isInteger(Number(n)) &&\n         Number(n) >= 0\n}\n\n/**\n * Lengthens an exsting array and fills new entries with 0 (does not mutate).\n * @private\n * @param {Array} arr The source array.\n * @param {number} dim The dimension of the new array.\n *\n * @returns {Array} A new array with length dim and arr as a prefix.\n */\nfunction promoteArrayDimension (arr, dim) {\n  return [...Array(dim)].map((_, i) => i < arr.length ? arr[i] : 0)\n}\n\n/**\n * Returns a string representing the type of an object. Similar to typeof, but\n * better with wrapped primitives, null, Array, etc...\n * @private\n * @param {*} obj The object to check the type of.\n *\n * @returns {string} A capitalized string describing the perceived type (i.e. 'Number', 'Array', etc...)\n */\nfunction type (obj) {\n  return Object.prototype.toString.call(obj).slice(8, -1)\n}\n\nmodule.exports = {\n  getVecType,\n  isVec,\n  vec2: vecTypes[2],\n  vec3: vecTypes[3],\n  vec4: vecTypes[4],\n\n  add,\n  multiply,\n  lerp,\n  slerp\n}\n","import React, { useRef, useMemo } from 'react'\nimport { useFrame, useThree } from '@react-three/fiber'\nimport { Group } from 'three'\nimport vecn from 'vecn'\n// @ts-ignore\nimport lerp from '@14islands/lerp'\n\nimport { ScrollScene, useScrollRig } from '@14islands/r3f-scroll-rig'\n\n// Sticky mesh that covers full viewport size\nconst StickyChild = ({\n  children,\n  childTop,\n  childBottom,\n  scrollState,\n  parentScale,\n  childScale,\n  scaleMultiplier,\n  priority,\n  stickyLerp = 1.0,\n  offsetTop = 0,\n}: any) => {\n  const group = useRef<Group>(null!)\n  const size = useThree((s) => s.size)\n\n  useFrame((_, delta) => {\n    if (!scrollState.inViewport) return\n\n    const topOffset = (childTop - offsetTop) / size.height\n    const bottomOffset = (childBottom / parentScale[1]) * scaleMultiplier\n\n    //  move to top of sticky area\n    const yTop = parentScale[1] * 0.5 - childScale[1] * 0.5 - offsetTop * scaleMultiplier\n    const yBottom = -parentScale[1] * 0.5 + childScale[1] * 0.5\n    const ySticky =\n      -childTop * scaleMultiplier +\n      yTop -\n      (scrollState.viewport - 1) * size.height * scaleMultiplier +\n      offsetTop * scaleMultiplier\n\n    let y = group.current.position.y\n\n    // enter\n    if (scrollState.viewport + topOffset < 1) {\n      y = yTop\n    }\n    // sticky\n    else if (scrollState.visibility - bottomOffset < 1) {\n      y = ySticky\n    }\n    // exit\n    else {\n      y = yBottom\n    }\n\n    group.current.position.y = lerp(group.current.position.y, y, stickyLerp, delta)\n  }, priority) // must happen after ScrollScene's useFrame to be buttery\n\n  return <group ref={group}>{children}</group>\n}\n\nconst renderAsSticky = (\n  el: any,\n  children: any,\n  size: any,\n  childStyle: any,\n  scaleMultiplier: number,\n  { stickyLerp, fillViewport }: any\n) => {\n  return ({ scale, ...props }: any) => {\n    let childScale = vecn.vec3(parseFloat(childStyle.width), parseFloat(childStyle.height), 1)\n    let childTop = parseFloat(childStyle.top)\n    let childBottom = size.height - childTop - childScale[1]\n\n    if (fillViewport) {\n      childScale = vecn.vec3(size.width, size.height, 1)\n      childTop = 0\n      childBottom = 0\n    }\n\n    const offsetTop = el.current.offsetTop\n\n    return (\n      // @ts-ignore\n      <StickyChild\n        offsetTop={offsetTop}\n        parentScale={scale}\n        childScale={childScale.times(scaleMultiplier)}\n        stickyLerp={stickyLerp}\n        childTop={childTop}\n        childBottom={childBottom}\n        scaleMultiplier={scaleMultiplier}\n        {...props}\n      >\n        {children({\n          scale: childScale.times(scaleMultiplier),\n          parentScale: scale,\n          ...props,\n        })}\n      </StickyChild>\n    )\n  }\n}\n\nexport const StickyScrollScene = ({ children, track, stickyLerp, fillViewport, ...props }: any) => {\n  const size = useThree((s) => s.size)\n  const { scaleMultiplier } = useScrollRig()\n\n  const internalRef = useRef(track.current)\n\n  // if tracked element is position:sticky, track the parent instead\n  // we want to track the progress of the entire sticky area\n  const childStyle = useMemo(() => {\n    const style = getComputedStyle(track.current)\n    if (style.position === 'sticky') {\n      internalRef.current = track.current.parentElement\n\n      // make sure parent is relative/absolute so we get accurante offsetTop\n      const parentStyle = getComputedStyle(internalRef.current)\n      if (parentStyle.position === 'static') {\n        console.error(\n          'StickyScrollScene: parent of position:sticky needs to be position:relative or position:absolute (currently set to position:static)'\n        )\n      }\n    } else {\n      console.error('StickyScrollScene: tracked element is not position:sticky')\n    }\n    return style\n  }, [track])\n\n  return (\n    <ScrollScene track={internalRef} {...props}>\n      {renderAsSticky(track, children, size, childStyle, scaleMultiplier, {\n        stickyLerp,\n        fillViewport,\n      })}\n    </ScrollScene>\n  )\n}\n","const _lerp = require('lerp')\n\n/**\n * Drop-in replacement of standard lerp with optional frame delta and target fps\n * to maintain constant animation speed at various fps\n * \n * Based on http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n * \n * @param {number} source Current value\n * @param {number} target Value to lerp towards\n * @param {number} rate Interpolation rate\n * @param {number} frameDelta Optional frame delta time in seconds. Should be 1/60 for a steady 60fps.\n * @param {number} targetFps Optional, target is 60 by default\n * @returns {number} interpolated value\n */\n\nfunction lerp(source, target, rate, frameDelta, targetFps = 60){\n  \n  // return normal lerp if no delta was passed\n  if (typeof frameDelta === 'undefined') {\n    return _lerp(source, target, rate)\n  }\n\n  const relativeDelta = frameDelta / (1 / targetFps)\n  const smoothing = 1 - rate\n  return _lerp(source, target, 1 - Math.pow(smoothing, relativeDelta));\n}\n\nmodule.exports = lerp","function lerp(v0, v1, t) {\n    return v0*(1-t)+v1*t\n}\nmodule.exports = lerp"],"names":["WebGLText","_ref","el","children","material","scale","font","fontOffsetY","fontOffsetX","overrideEmissive","color","props","_objectWithoutPropertiesLoose","_excluded","size","useThree","scaleMultiplier","useScrollRig","textColor","fontSize","textAlign","lineHeight","letterSpacing","useMemo","current","cs","window","getComputedStyle","parentElement","parseFloat","useEffect","emissive","xOffset","React","createElement","Text","_extends","maxWidth","width","overflowWrap","anchorX","anchorY","position","height","WebGLImage","forwardRef","ref","scrollState","vertexShader","fragmentShader","invalidateFrameLoop","widthSegments","heightSegments","useRef","mesh","useImperativeHandle","invalidate","gl","pixelRatio","s","viewport","dpr","scroll","useScrollbar","texture","useImageAsTexture","uniforms","u_color","value","Color","u_time","u_pixelRatio","u_progress","u_visibility","u_viewport","u_velocity","u_res","Vector2","u_rect","u_size","u_texture","u_loaded","u_scaleMultiplier","set","image","useFrame","_","delta","inViewport","x","y","velocity","progress","visibility","args","Fragment","attach","transparent","ParallaxGroup","parallax","ParallaxScrollScene","speed","parallaxAmount","ScrollScene","scissor","inViewportMargin","Math","max","vecTypes","Proxy","get","obj","prop","hasOwnProperty","getVecType","vecn","Array","constructor","dimension","flattenOuter","every","type","TypeError","length","Error","fill","super","this","Reflect","defineProperty","undefined","enumerable","magnitude","pnorm","div","v","checkCompatibility","dim","result","i","minus","neg","times","plus","pow","p","dot","normalize","abs","reflect","normal","n","argmax","maxVal","reduce","acc","concat","argmin","minVal","min","choose","indices","isArray","isIndex","toString","RangeError","forEach","push","copy","equals","approximatelyEquals","epsilon","sum","toArray","from","apply","filter","map","slice","splice","test","validator","Number","swizzleSymbolMap","getSwizzleSymbolMap","newVals","item","split","some","c","valid","unique","SyntaxError","index","swizzleSet","newDim","values","swizzleGet","isNaN","isInteger","classname","VecType","arr","promoteArrayDimension","writable","target","Object","preventExtensions","namedIndices","z","w","r","g","b","a","t","q","find","o","numberValid","prototype","call","src","isVec","vec2","vec3","vec4","add","vecs","multiply","lerp","v1","v2","slerp","theta","acos","relative","cos","sin","_excluded2","StickyChild","childTop","childBottom","parentScale","childScale","priority","stickyLerp","offsetTop","group","yTop","source","rate","frameDelta","targetFps","StickyScrollScene","_ref2","track","fillViewport","internalRef","childStyle","style","console","error","renderAsSticky","top"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"powerups.modern.js","sources":["../powerups/WebGLText.tsx","../powerups/WebGLImage.tsx","../powerups/ParallaxScrollScene.tsx","../node_modules/vecn/src/index.js","../powerups/StickyScrollScene.tsx","../node_modules/@14islands/lerp/index.js","../node_modules/lerp/index.js"],"sourcesContent":["// @ts-ignore\n\nimport React, { useMemo, useEffect, ReactNode, MutableRefObject } from 'react'\nimport { Color, Material } from 'three'\nimport { useThree } from '@react-three/fiber'\nimport { Text } from '@react-three/drei'\n\nimport { useScrollRig } from '@14islands/r3f-scroll-rig'\n\n/**\n * Returns a WebGL Troika text mesh styled as the source DOM element\n */\n\ninterface WebGLTextProps {\n  el: MutableRefObject<HTMLElement>\n  children?: ReactNode\n  material?: Material\n  scale?: any\n  font?: string\n  fontOffsetY?: number\n  fontOffsetX?: number\n  overrideEmissive?: boolean\n  color?: string\n}\n\nexport const WebGLText = ({\n  el,\n  children,\n  material,\n  scale,\n  font,\n  fontOffsetY = 0,\n  fontOffsetX = 0,\n  overrideEmissive = false,\n  color,\n  ...props\n}: WebGLTextProps) => {\n  const { size } = useThree()\n  const { scaleMultiplier } = useScrollRig()\n\n  const { textColor, fontSize, textAlign, lineHeight, letterSpacing } = useMemo(() => {\n    if (!el.current) return {}\n    const cs = window.getComputedStyle(el.current)\n\n    // get color from parent if set to transparent\n    let textColor = color || cs.color\n    if (!color && cs.color === 'rgba(0, 0, 0, 0)' && el.current.parentElement) {\n      textColor = window.getComputedStyle(el.current.parentElement).color\n    }\n\n    // font size relative letter spacing\n    const letterSpacing = (parseFloat(cs.letterSpacing) || 0) / parseFloat(cs.fontSize)\n    const lineHeight = (parseFloat(cs.lineHeight) || 0) / parseFloat(cs.fontSize)\n\n    return {\n      letterSpacing,\n      lineHeight,\n      textColor,\n      fontSize: parseFloat(cs.fontSize) * scaleMultiplier,\n      textAlign: cs.textAlign,\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [el, size, scale, color, scaleMultiplier]) // recalc on resize\n\n  useEffect(() => {\n    if (material && overrideEmissive) {\n      // @ts-ignore\n      material.emissive = color\n    }\n  }, [material, color, overrideEmissive])\n\n  let xOffset = 0\n  if (textAlign === 'left' || textAlign === 'start') {\n    xOffset = scale[0] * -0.5\n  } else if (textAlign === 'right' || textAlign === 'end') {\n    xOffset = scale[0] * 0.5\n  }\n\n  const yOffset = scale ? scale[1] * 0.5 : size.height * 0.5\n\n  return (\n    <Text\n      fontSize={fontSize}\n      maxWidth={scale ? scale[0] : size.width}\n      lineHeight={lineHeight}\n      // @ts-ignore\n      textAlign={textAlign}\n      letterSpacing={letterSpacing}\n      overflowWrap=\"break-word\"\n      font={font}\n      color={textColor}\n      // @ts-ignore\n      anchorX={textAlign}\n      anchorY=\"top\" // so text moves down if row breaks\n      // @ts-ignore\n      position={[xOffset + fontSize * fontOffsetX, yOffset + fontSize * fontOffsetY, 0]} // font specific\n      material={material}\n      {...props}\n    >\n      {children}\n    </Text>\n  )\n}\n","// @ts-ignore\n\nimport React, {\n  useRef,\n  useMemo,\n  useEffect,\n  forwardRef,\n  MutableRefObject,\n  ForwardedRef,\n  useImperativeHandle,\n} from 'react'\nimport { Color, Vector2, ShaderMaterial, Mesh, ShaderMaterialParameters } from 'three'\nimport { useFrame, useThree } from '@react-three/fiber'\n\nimport { useScrollRig, useImageAsTexture, useScrollbar } from '@14islands/r3f-scroll-rig'\n\ninterface WebGLImageProps {\n  el: MutableRefObject<HTMLImageElement>\n  scale?: any\n  scrollState?: any\n  vertexShader?: string\n  fragmentShader?: string\n  invalidateFrameLoop: boolean\n  widthSegments?: number\n  heightSegments?: number\n}\n\nexport const WebGLImage = forwardRef(\n  (\n    {\n      el,\n      scale,\n      scrollState,\n      vertexShader,\n      fragmentShader,\n      invalidateFrameLoop = false,\n      widthSegments = 128,\n      heightSegments = 128,\n      ...props\n    }: WebGLImageProps,\n    ref: ForwardedRef<Mesh>\n  ) => {\n    const material = useRef<ShaderMaterial>(null!)\n    const mesh = useRef<Mesh>(null!)\n    useImperativeHandle(ref, () => mesh.current)\n\n    const { invalidate, gl, size } = useThree()\n    const pixelRatio = useThree((s) => s.viewport.dpr)\n    const { scroll } = useScrollbar()\n    const { scaleMultiplier } = useScrollRig()\n\n    const texture = useImageAsTexture(el)\n\n    const uniforms = useMemo(() => {\n      return {\n        u_color: { value: new Color('black') },\n        u_time: { value: 0 },\n        u_pixelRatio: { value: pixelRatio },\n        u_progress: { value: 0 },\n        u_visibility: { value: 0 },\n        u_viewport: { value: 0 },\n        u_velocity: { value: 0 }, // scroll speed\n        u_res: { value: new Vector2() }, // screen dimensions\n        u_rect: { value: new Vector2() }, // DOM el dimensions\n        u_size: { value: new Vector2() }, // Texture dimensions\n        u_texture: { value: null },\n        u_loaded: { value: false },\n        u_scaleMultiplier: { value: scaleMultiplier },\n      }\n    }, [pixelRatio])\n\n    // Fade in when texture loaded\n    useEffect(() => {\n      if (!texture) return\n      if (!material.current) return\n      material.current.uniforms.u_texture.value = texture\n      material.current.uniforms.u_size.value.set(texture.image.width, texture.image.height)\n      material.current.uniforms.u_loaded.value = true\n    }, [texture, gl])\n\n    useEffect(() => {\n      if (!material.current) return\n      material.current.uniforms.u_res.value.set(size.width, size.height)\n      material.current.uniforms.u_rect.value.set(scale?.[0], scale?.[1])\n    }, [size, scale])\n\n    useFrame((_, delta) => {\n      if (!scrollState.inViewport || !mesh.current || !material.current) return\n\n      if (!material.current.uniforms.u_loaded.value) return\n\n      material.current.uniforms.u_time.value += delta\n\n      // update scale while animating too\n      material.current.uniforms.u_rect.value.set(mesh.current.scale.x, mesh.current.scale.y)\n\n      // px velocity\n      material.current.uniforms.u_velocity.value = scroll.velocity\n\n      // percent of total visible distance that was scrolled (0 = just outside bottom of screen, 1 = just outside top of screen)\n      material.current.uniforms.u_progress.value = scrollState.progress\n\n      // percent of item height in view\n      material.current.uniforms.u_visibility.value = scrollState.visibility\n      // percent of window height scrolled since visible\n      material.current.uniforms.u_viewport.value = scrollState.viewport\n\n      if (invalidateFrameLoop) invalidate()\n    })\n\n    const args = useMemo(\n      () => [\n        {\n          vertexShader,\n          fragmentShader,\n        },\n      ],\n      [vertexShader, fragmentShader]\n    )\n\n    return (\n      <>\n        <mesh ref={mesh} {...props}>\n          <planeGeometry attach=\"geometry\" args={[1, 1, widthSegments, heightSegments]} />\n          <shaderMaterial\n            ref={material}\n            args={args as [ShaderMaterialParameters]}\n            transparent={true}\n            uniforms={uniforms}\n          />\n        </mesh>\n      </>\n    )\n  }\n)\n","// @ts-ignore\n\nimport React, { useRef } from 'react'\nimport { useFrame, useThree } from '@react-three/fiber'\nimport { Mesh } from 'three'\n\nimport { ScrollScene, useScrollRig } from '@14islands/r3f-scroll-rig'\n\n// Parallax group inside ScrollScene\nconst ParallaxGroup = ({ children, scrollState, parallax }: any) => {\n  const mesh = useRef<Mesh>(null!)\n  const size = useThree((s) => s.size)\n  const { scaleMultiplier } = useScrollRig()\n\n  useFrame(() => {\n    if (!scrollState.inViewport) return\n    const parallaxProgress = scrollState.progress * 2 - 1\n    mesh.current.position.y = parallax * parallaxProgress * scaleMultiplier * size.height\n  })\n\n  return <mesh ref={mesh}>{children}</mesh>\n}\n\n/* Speed=1 is no parallax */\nexport const ParallaxScrollScene = ({ children, speed = 1, ...props }: any) => {\n  const extraMargin = 50 // add 50vh extra margin to avoid aggressive clipping\n  const parallaxAmount = speed - 1\n  return (\n    <ScrollScene scissor={false} inViewportMargin={`${Math.max(0, 1 - 0.5) * 200 + extraMargin}%`} {...props}>\n      {(props: any) => (\n        <ParallaxGroup parallax={parallaxAmount} {...props}>\n          {children(props)}\n        </ParallaxGroup>\n      )}\n    </ScrollScene>\n  )\n}\n","/**\n * An object for memoizing vecType functions.\n * @type {Object}\n * @private\n */\nlet vecTypes = (function () {\n  const handler = {\n    get: function (obj, prop) {\n      if (!obj.hasOwnProperty(prop)) {\n        obj[prop] = getVecType(prop)\n      }\n      return obj[prop]\n    }\n  }\n\n  return new Proxy({}, handler)\n})()\n\n/**\n * A class for fixed-size vectors of numbers.\n * @extends Array\n */\nclass vecn extends Array {\n  /**\n   * Creates a vecn of the specified dimension. This should never be called\n   * by the user (as if this were an abstract class).\n   * @param {number} dimension The dimension of this vector.\n   * @param {number[]} [args=[]] The numbers to be put in the vector.\n   */\n  constructor (dimension, args) {\n    args = flattenOuter(args)\n\n    if (!args.every((x) => type(x) === 'Number')) {\n      throw new TypeError('All arguments must be numbers.')\n    }\n    if (args.length > 1 && args.length !== dimension) {\n      throw new Error('Argument list must be empty, have a single number, or have a length equal to the dimension.')\n    }\n\n    if (args.length === 0) {\n      args = [0]\n    }\n    if (args.length === 1 && type(args[0]) === 'Number') {\n      args = Array(dimension).fill(args[0])\n    }\n\n    if (dimension > 1) {\n      super(...args)\n    } else {\n      super(1)\n      this[0] = args[0]\n    }\n\n    Reflect.defineProperty(this, 'pop', {\n      value: undefined,\n      enumerable: false\n    })\n    Reflect.defineProperty(this, 'push', {\n      value: undefined,\n      enumerable: false\n    })\n    Reflect.defineProperty(this, 'shift', {\n      value: undefined,\n      enumerable: false\n    })\n    Reflect.defineProperty(this, 'unshift', {\n      value: undefined,\n      enumerable: false\n    })\n  }\n\n  /**\n   * The L2 norm (Euclidian norm) of the vector.\n   * @type {number}\n   */\n  get magnitude () {\n    return this.pnorm(2)\n  }\n\n  // --------------------------------------------------------------------------\n  //   Arithmetic\n\n  /**\n   * Returns a vector where this is divided by v componentwise. If v is\n   * a single number, the vector is scaled by 1/v.\n   * @param {number|number[]} v The value to multiply with.\n   *\n   * @returns {vecn} A new vector with the divided components.\n   */\n  div (v) {\n    checkCompatibility(v, this.dim, true)\n    if (type(v) === 'Number') {\n      v = (new Array(this.dim)).fill(v)\n    }\n\n    let result = []\n    for (let i = 0; i < this.length; ++i) {\n      result[i] = this[i] / v[i]\n    }\n    return vecTypes[this.dim](result)\n  }\n\n  /**\n   * Returns a vector where v is subtracted from the components of this\n   * vector. If v is a single number, it is subtracted to each component. If v\n   * is a vector, the vectors are combined componentwise.\n   * @param {number|number[]} v The value to subtract from this vector.\n   *\n   * @returns {vecn} A new vector with the combined components.\n   */\n  minus (v) {\n    checkCompatibility(v, this.dim, true)\n    if (type(v) === 'Number') {\n      v = (new Array(this.dim)).fill(v)\n    }\n\n    let result = []\n    for (let i = 0; i < this.dim; ++i) {\n      result[i] = this[i] - v[i]\n    }\n    return vecTypes[this.dim](result)\n  }\n\n  /**\n   * Negates each element in this vector.\n   * @returns {vecn} A new vector where all elements are negated.\n   */\n  neg () {\n    return vecTypes[this.dim](this.times(-1))\n  }\n\n  /**\n   * Returns a vector where v is added to the components of this vector. If v\n   * is a single number, it is added to each component. If v is a vector, the\n   * vectors are added componentwise.\n   * @param {number|number[]} v The value to add to this vector.\n   *\n   * @returns {vecn} A new vector with the summed components.\n   */\n  plus (v) {\n    checkCompatibility(v, this.dim, true)\n    if (type(v) === 'Number') {\n      v = (new Array(this.dim)).fill(v)\n    }\n\n    let result = []\n    for (let i = 0; i < this.dim; ++i) {\n      result[i] = this[i] + v[i]\n    }\n    return vecTypes[this.dim](result)\n  }\n\n  /**\n   * Returns a vector where each component of this was raised to a power p.\n   * @param {number} p The power to raise each component by.\n   *\n   * @returns {vecn} A new vector with the exponentiated components.\n   */\n  pow (p) {\n    let result = []\n    for (let i = 0; i < this.dim; ++i) {\n      result[i] = Math.pow(this[i], p)\n    }\n    return vecTypes[this.dim](result)\n  }\n\n  /**\n   * Returns a vector where v and this are multiplied componentwise. If v is\n   * a single number, the vector is scaled by v.\n   * @param {number|number[]} v The value to multiply with.\n   *\n   * @returns {vecn} A new vector with the multiplied components.\n   */\n  times (v) {\n    checkCompatibility(v, this.dim, true)\n    if (type(v) === 'Number') {\n      v = (new Array(this.dim)).fill(v)\n    }\n\n    let result = []\n    for (let i = 0; i < this.dim; ++i) {\n      result[i] = this[i] * v[i]\n    }\n    return vecTypes[this.dim](result)\n  }\n\n  // --------------------------------------------------------------------------\n  //   Vector Operations\n\n  /**\n   * Dot product of two vectors.\n   * @param {number[]} v The vector to dot with this one.\n   *\n   * @returns {number} The dot product between this and v.\n   */\n  dot (v) {\n    checkCompatibility(v, this.dim)\n\n    let result = 0\n    for (let i = 0; i < this.dim; ++i) {\n      result += this[i] * v[i]\n    }\n    return result\n  }\n\n  /**\n   * Scales this vector to a magnitude of 1.\n   *\n   * @returns {vecn} A new vector with scaled components.\n   */\n  normalize () {\n    return this.div(this.magnitude)\n  }\n\n  /**\n   * Evaluates the p-norm (or lp-norm) of this vector.\n   * @param {number} p The p-value to evaluate.\n   *\n   * @returns {number} The norm of this vector.\n   */\n  pnorm (p) {\n    let result = 0\n    for (let i = 0; i < this.dim; ++i) {\n      result += Math.pow(Math.abs(this[i]), p)\n    }\n    return Math.pow(result, 1 / p)\n  }\n\n  /**\n   * Reflects this vector across the provided vector. The normal can be imagined\n   * as a surface normal or as describing a hyperpalane.\n   * @param {number[]} normal A vector describing the hyperplane to reflect off of.\n   *\n   * @returns {vecn} The reflected vector.\n   */\n  reflect (normal) {\n    const n = normal.normalize()\n    return this.minus(n.times(2 * this.dot(n)))\n  }\n\n  // --------------------------------------------------------------------------\n  //   Extras\n\n  /**\n   * Finds the indices of the max value in this vector.\n   *\n   * @returns {number[]} An array of indices corresponding to the max values.\n   */\n  argmax () {\n    const maxVal = this.max()\n    return this.reduce((acc, x, i) => x === maxVal ? acc.concat([i]) : acc, [])\n  }\n\n  /**\n   * Finds the indices of the min value in this vector.\n   *\n   * @returns {number[]} An array of indices corresponding to the min values.\n   */\n  argmin () {\n    const minVal = this.min()\n    return this.reduce((acc, x, i) => x === minVal ? acc.concat([i]) : acc, [])\n  }\n\n  /**\n   * Creates a new vector from the provided indices of this one. Basically\n   * equivalent to swizzling.\n   * @param {number[]} indices The indices to select into a new vector.\n   *\n   * @returns {vecn} A new vector from the provided indices.\n   */\n  choose (indices) {\n    if (!Array.isArray(indices)) {\n      throw new TypeError('Argument must be a list of indices.')\n    }\n    if (!indices.every((i) => i < this.dim && isIndex(i.toString()))) {\n      throw new RangeError('All elements of argument must be valid indices.')\n    }\n\n    let v = []\n    indices.forEach((i) => v.push(this[i]))\n    return vecTypes[v.length](v)\n  }\n\n  /**\n   * Creates a duplicate of this vector. Same as passing this vector through\n   * the factory that created it.\n   *\n   * @returns {vecn} A deep copy of this vector.\n   */\n  copy () {\n    return vecTypes[this.dim](this)\n  }\n\n  /**\n   * Returns whether every element in each vector is equal.\n   * @param {number[]} v A vector to test against.\n   *\n   * @returns {boolean} True if both vectors have the same dimension and values.\n   */\n  equals (v) {\n    return v.length === this.dim && v.every((x, i) => this[i] === x)\n  }\n\n  /**\n   * Returns whether every element in each vector is approximately equal.\n   * @param {number[]} v A vector to test against.\n   * @param {number} epsilon The largest meaningful difference between two values.\n   *\n   * @returns {boolean} True if both vectors have the same dimension and the\n   * distance between each number is less than epsilon.\n   */\n  approximatelyEquals (v, epsilon = 0.00000001) {\n    return v.length === this.dim && v.every((x, i) => Math.abs(this[i] - x) < epsilon)\n  }\n\n  /**\n   * Returns the max value of this vector.\n   *\n   * @returns {number} The max value of this vector.\n   */\n  max () {\n    return Math.max(...this)\n  }\n\n  /**\n   * Returns the min value of this vector.\n   *\n   * @returns {number} The min value of this vector.\n   */\n  min () {\n    return Math.min(...this)\n  }\n\n  /**\n   * Sums the components of this vector.\n   *\n   * @returns {number} The sum of the components of this vector.\n   */\n  sum () {\n    return this.reduce((acc, x) => acc + x, 0)\n  }\n\n  /**\n   * Converts this vector into an Array.\n   *\n   * @returns {number[]} An array of the contents of this vector.\n   */\n  toArray () {\n    return Array.from(this)\n  }\n\n  // --------------------------------------------------------------------------\n  //   Array Overrides\n\n  /**\n   * Same as Array.prototype.concat, but return value is of a new vecType.\n   *\n   * @returns {vecn}\n   */\n  concat (...args) {\n    const result = super.concat.apply(this.toArray(), args)\n    return vecTypes[result.length](result)\n  }\n\n  /**\n   * Same as Array.prototype.filter, but returns an Array if the result has 0\n   * entries.\n   *\n   * @returns {vecn|number[]}\n   */\n  filter (...args) {\n    const result = super.filter.apply(this.toArray(), args)\n    if (result.length > 0) {\n      return vecTypes[result.length](result)\n    }\n    return result\n  }\n\n  /**\n   * Same as Array.prototype.map, but returns an Array if the result contains\n   * non-numbers.\n   *\n   * @returns {vecn|Array}\n   */\n  map (...args) {\n    const result = super.map(...args)\n    if (result.every((x) => type(x) === 'Number')) {\n      return result\n    }\n    return result.toArray()\n  }\n\n  /**\n   * Same as Array.prototype.slice, but returns an Array if the result has 0\n   * entries.\n   */\n  slice (...args) {\n    const result = super.slice.apply(this.toArray(), args)\n    if (result.length > 0) {\n      return vecTypes[result.length](result)\n    }\n    return result\n  }\n\n  /**\n   * A restrictive version of the Array.prototype.splice that requires all\n   * removed elements to be replaced.\n   */\n  splice (...args) {\n    let test = this.toArray()\n    test.splice(...args)\n\n    if (test.length !== this.dim) {\n      throw new Error('All removed elements must be replaced.')\n    }\n    if (!test.every((x) => type(x) === 'Number')) {\n      throw new TypeError('All elements must be numbers.')\n    }\n\n    test.forEach((x, i) => { this[i] = x })\n  }\n\n  toString () {\n    return this.reduce((s, x, i) => {\n      return s + x + (i === this.dim - 1 ? ' ' : ', ')\n    }, '[ ') + ']'\n  }\n}\n\n// --------------------------------------------------------------------------\n//   General Tools\n\n/**\n * Adds an arbitrary number of vectors together. All vectors must be of the same\n * dimension.\n * @param {...vecn} vecs Vectors to add together.\n *\n * @returns {vecn} The sum of all the provided vectors.\n */\nfunction add (...vecs) {\n  const dim = vecs[0].dim\n  if (!vecs.every((v) => v.dim === dim)) {\n    throw new TypeError('All vectors must have the same dimension.')\n  }\n  return vecs.reduce((acc, v) => acc.plus(v), vecTypes[dim]())\n}\n\n/**\n * The validator to be used in the proxy for all vec objects. Catches swizzling\n * properties, makes sure assignment only works for indices, and disallows\n * non-numerical assignments. Used in getVecType.\n * @constant\n * @type {Object}\n * @private\n */\nconst validator = {\n  set: function (obj, prop, value) {\n    if (prop === 'length') {\n      return false\n    }\n    if (isIndex(prop)) {\n      if (Number(prop) >= obj.dim) {\n        throw new RangeError('Vector may not have more elements than dimension.')\n      } else if (type(value) !== 'Number') {\n        throw new TypeError('Vectors may only contain numbers.')\n      } else {\n        obj[prop] = value\n        return true\n      }\n    }\n\n    const swizzleSymbolMap = getSwizzleSymbolMap(prop.toString())\n    if (obj.dim <= 4 && swizzleSymbolMap) {\n      swizzleSet(obj, prop.toString(), swizzleSymbolMap, value)\n      return true\n    }\n\n    return false\n  },\n  get: function (obj, prop) {\n    const swizzleSymbolMap = getSwizzleSymbolMap(prop.toString())\n    if (obj.dim <= 4 && swizzleSymbolMap) {\n      return swizzleGet(obj, prop, swizzleSymbolMap)\n    }\n\n    return obj[prop]\n  }\n}\n\n/**\n * Returns a factory function for vectors of the specified dimension.\n * @param {number} dim The dimension of the new vector type.\n *\n * @returns {Function} A factory (not a constructor) for creating new vecs.\n */\nfunction getVecType (dim) {\n  dim = Number(dim)\n\n  if (!(dim in vecTypes)) {\n    if (isNaN(dim)) throw new TypeError('Dimension must be coercible to a number.')\n    if (dim <= 0) throw new RangeError('Dimension must be positive.')\n    if (!Number.isInteger(dim)) throw new RangeError('Dimension must be positive.')\n\n    // Doing a little bit of exploiting ES6 to dynamically name the class\n    let classname = 'vec' + dim\n    let VecType = ({[classname]: class extends vecn {\n      constructor (...args) {\n        if (args.length === 1 && args[0] instanceof vecn) {\n          if (args[0].dim > dim) {\n            throw new TypeError('Cannot demote vectors.')\n          }\n          args = promoteArrayDimension(args[0].toArray(), dim)\n        }\n        super(dim, args)\n        Reflect.defineProperty(this, 'dim', {\n          value: dim,\n          writable: false,\n          enumerable: false\n        })\n      }\n    }})[classname]\n\n    let factory = function factory (...args) {\n      let target = new VecType(...args)\n      Object.preventExtensions(target)\n      return new Proxy(target, validator)\n    }\n    vecTypes[dim] = factory\n  }\n\n  return vecTypes[dim]\n}\n\n/**\n * The correct function for determining whether an object is a vecn.\n * @param {*} v The object in question.\n *\n * @returns {boolean} True if the object is an instance of vecn.\n */\nfunction isVec (v) {\n  return v instanceof vecn\n}\n\n/**\n * Linearly interpolates between two vectors.\n * @param {vecn} v1 The starting vector.\n * @param {vecn} v2 The ending vector.\n * @param {number} t The interpolant, which is clamped to the inteval [0, 1].\n *\n * @returns {vecn} The interpolated vector.\n */\nfunction lerp (v1, v2, t) {\n  if (v1.dim !== v2.dim) throw new TypeError('Vectors must have the same dimension.')\n  t = t < 0 ? 0 : (t > 1 ? 1 : t)\n  return v1.plus(v2.minus(v1).times(t))\n}\n\n/**\n * Multiplies an arbitrary number of vectors together. All vectors must be of the same\n * dimension.\n * @param {...vecn} vecs Vectors to multiply together.\n *\n * @returns {vecn} The product of all the provided vectors.\n */\nfunction multiply (...vecs) {\n  const dim = vecs[0].dim\n  if (!vecs.every((v) => v.dim === dim)) throw new TypeError('All vectors must have the same dimension.')\n  return vecs.reduce((acc, v) => acc.times(v), vecTypes[dim](1))\n}\n\n/**\n * Spherically interpolates between two vectors.\n * @param {vecn} v1 The starting vector.\n * @param {vecn} v2 The ending vector.\n * @param {number} t The interpolant, which is clamped to the inteval [0, 1].\n *\n * @returns {vecn} The interpolated vector.\n */\nfunction slerp (v1, v2, t) {\n  if (v1.dim !== v2.dim) throw new TypeError('Vectors must have the same dimension.')\n\n  t = t < 0 ? 0 : (t > 1 ? 1 : t)\n  let dot = v1.normalize().dot(v2.normalize())\n  dot = dot < -1 ? -1 : (dot > 1 ? 1 : dot)\n  const theta = Math.acos(dot) * t\n  const relative = v2.minus(v1.times(dot)).normalize()\n  const magnitude = v1.magnitude + ((v2.magnitude - v1.magnitude) * t)\n  return v1.times(Math.cos(theta)).plus(relative.times(Math.sin(theta)))\n    .normalize().times(magnitude)\n}\n\n// --------------------------------------------------------------------------\n//   Swizzling\n\n/**\n * The index corresponding to common names for indexing vectors.\n * @constant\n * @type {Object}\n * @private\n */\nconst namedIndices = [\n  {x: 0, y: 1, z: 2, w: 3},\n  {r: 0, g: 1, b: 2, a: 3},\n  {s: 0, t: 1, p: 2, q: 3}\n]\n\n/**\n * Gets the set of symbols corresponding to indices used for swizzling.\n * @private\n * @param {string} s The string used as a property to swizzle.\n *\n * @returns {Object} A map from characters to indices.\n */\nfunction getSwizzleSymbolMap (s) {\n  return namedIndices.find((map) => {\n    return s.split('').every((c) => c in map)\n  })\n}\n\n/**\n * Creates a new vector from the named indices given by swizzling.\n * @private\n * @param {vecn} v The vector to pull data from. The dimension is assumed to be\n * 2, 3, or 4, but this isn't enforced here.\n * @param {string} s The property being used to swizzle (e.g. 'xxy' or 'z').\n * @param {Object} set A map from characters to indices (assumed to be valid).\n *\n * @returns {undefined|number|vecn} Either undefined (if s isn't a valid swizzle\n * string), a number (if s has a length of 1), or a vecn where the values have\n * been rearranged according to the order given in s.\n */\nfunction swizzleGet (v, s, set) {\n  const newDim = s.length\n\n  if (newDim === 1) {\n    return v[set[s]]\n  }\n\n  let values = s.split('').reduce((acc, x) => {\n    let i = set[x]\n    return acc && i < v.dim ? acc.concat([v[i]]) : undefined\n  }, [])\n  return values ? new vecTypes[newDim](...values) : undefined\n}\n\n/**\n * Assigns the indexed values in v to the values in newVals in the order they\n * are described in in s.\n * @private\n * @param {vecn} v The starting vector.\n * @param {string} s The property being used to swizzle (e.g. 'xyz' or 'xz').\n * @param {Object} map A map from characters to indices (assumed to be valid).\n * @param {number|number[]} newVals The right hand side of the assignment\n *\n * @returns {vecn} A copy of v with the correct elements replaced.\n */\nfunction swizzleSet (v, s, map, newVals) {\n  if (s.length === 1) {\n    if (type(newVals) !== 'Number') {\n      throw new TypeError('Must set to a number')\n    }\n    v[map[s]] = newVals\n    return\n  }\n\n  if (!Array.isArray(newVals)) throw new TypeError('Right-hand side must be an array.')\n  if (s.length !== newVals.length) throw new TypeError('Right-hand side must have matching length.')\n  if (!newVals.every((item) => type(item) === 'Number')) throw new TypeError('All new values must be numbers.')\n\n  if (s.split('').some((c) => map[c] >= v.dim)) {\n    return\n  }\n\n  let valid = true\n  for (let i = 0, unique = {}; i < s.length; ++i) {\n    if (unique.hasOwnProperty(s[i])) {\n      valid = false\n      break\n    }\n    unique[s[i]] = true\n  }\n  if (!valid) throw new SyntaxError('Swizzle assignment does not allow symbols to be repeated.')\n\n  s.split('').map((c) => map[c]).forEach((index, i) => { v[index] = newVals[i] })\n}\n\n// --------------------------------------------------------------------------\n//   Helpers\n\n/**\n * Checks whether something is valid to do vector operations with and throws\n * a TypeError if not.\n * @private\n * @param {*} o An object to check.\n * @param {number} dim The dimension to check against.\n * @param {boolean} [numberValid=false] Whether scalars are compatible for the operation.\n */\nfunction checkCompatibility (o, dim, numberValid = false) {\n  if (numberValid && type(o) === 'Number') {\n    return\n  } else if (o.length && o.length === dim) {\n    return\n  }\n  throw new TypeError(`Invalid argument. Input must have matching dimension${numberValid ? 'or be a scalar' : ''}.`)\n}\n\n/**\n * Removes outer arrays and returns a reference to the innermost array. For\n * example, [[1, 2]] becomes [1, 2]. [[[['a'], true]]] becomes [['a'], true].\n * @private\n * @param {Array} arr The array to flatten.\n *\n * @returns {Array} A reference to the innermost array in arr.\n */\nfunction flattenOuter (arr) {\n  if (!(arr instanceof Array) || arr.length !== 1) {\n    return arr\n  }\n  if (arr[0] instanceof Array) {\n    return flattenOuter(arr[0])\n  }\n  return arr\n}\n\n/**\n * Checks whether a provided string can be used as a valid index into an array.\n * @private\n * @param {string} n A string representation of the number in question.\n *\n * @returns {boolean} True if n can be used to index an array.\n */\nfunction isIndex (n) {\n  return !isNaN(n) &&\n         Number(n).toString() === n &&\n         Number.isInteger(Number(n)) &&\n         Number(n) >= 0\n}\n\n/**\n * Lengthens an exsting array and fills new entries with 0 (does not mutate).\n * @private\n * @param {Array} arr The source array.\n * @param {number} dim The dimension of the new array.\n *\n * @returns {Array} A new array with length dim and arr as a prefix.\n */\nfunction promoteArrayDimension (arr, dim) {\n  return [...Array(dim)].map((_, i) => i < arr.length ? arr[i] : 0)\n}\n\n/**\n * Returns a string representing the type of an object. Similar to typeof, but\n * better with wrapped primitives, null, Array, etc...\n * @private\n * @param {*} obj The object to check the type of.\n *\n * @returns {string} A capitalized string describing the perceived type (i.e. 'Number', 'Array', etc...)\n */\nfunction type (obj) {\n  return Object.prototype.toString.call(obj).slice(8, -1)\n}\n\nmodule.exports = {\n  getVecType,\n  isVec,\n  vec2: vecTypes[2],\n  vec3: vecTypes[3],\n  vec4: vecTypes[4],\n\n  add,\n  multiply,\n  lerp,\n  slerp\n}\n","// @ts-ignore\n\nimport React, { useRef, useMemo } from 'react'\nimport { useFrame, useThree } from '@react-three/fiber'\nimport { Group } from 'three'\nimport vecn from 'vecn'\n// @ts-ignore\nimport lerp from '@14islands/lerp'\n\nimport { ScrollScene, useScrollRig } from '@14islands/r3f-scroll-rig'\n\n// Sticky mesh that covers full viewport size\nconst StickyChild = ({\n  children,\n  childTop,\n  childBottom,\n  scrollState,\n  parentScale,\n  childScale,\n  scaleMultiplier,\n  priority,\n  stickyLerp = 1.0,\n  offsetTop = 0,\n}: any) => {\n  const group = useRef<Group>(null!)\n  const size = useThree((s) => s.size)\n\n  useFrame((_, delta) => {\n    if (!scrollState.inViewport) return\n\n    const topOffset = (childTop - offsetTop) / size.height\n    const bottomOffset = (childBottom / parentScale[1]) * scaleMultiplier\n\n    //  move to top of sticky area\n    const yTop = parentScale[1] * 0.5 - childScale[1] * 0.5 - offsetTop * scaleMultiplier\n    const yBottom = -parentScale[1] * 0.5 + childScale[1] * 0.5\n    const ySticky =\n      -childTop * scaleMultiplier +\n      yTop -\n      (scrollState.viewport - 1) * size.height * scaleMultiplier +\n      offsetTop * scaleMultiplier\n\n    let y = group.current.position.y\n\n    // enter\n    if (scrollState.viewport + topOffset < 1) {\n      y = yTop\n    }\n    // sticky\n    else if (scrollState.visibility - bottomOffset < 1) {\n      y = ySticky\n    }\n    // exit\n    else {\n      y = yBottom\n    }\n\n    group.current.position.y = lerp(group.current.position.y, y, stickyLerp, delta)\n  }, priority) // must happen after ScrollScene's useFrame to be buttery\n\n  return <group ref={group}>{children}</group>\n}\n\nconst renderAsSticky = (\n  el: any,\n  children: any,\n  size: any,\n  childStyle: any,\n  scaleMultiplier: number,\n  { stickyLerp, fillViewport }: any\n) => {\n  return ({ scale, ...props }: any) => {\n    let childScale = vecn.vec3(parseFloat(childStyle.width), parseFloat(childStyle.height), 1)\n    let childTop = parseFloat(childStyle.top)\n    let childBottom = size.height - childTop - childScale[1]\n\n    if (fillViewport) {\n      childScale = vecn.vec3(size.width, size.height, 1)\n      childTop = 0\n      childBottom = 0\n    }\n\n    const offsetTop = useRef(el.current.offsetTop).current;\n\n    return (\n      // @ts-ignore\n      <StickyChild\n        offsetTop={offsetTop}\n        parentScale={scale}\n        childScale={childScale.times(scaleMultiplier)}\n        stickyLerp={stickyLerp}\n        childTop={childTop}\n        childBottom={childBottom}\n        scaleMultiplier={scaleMultiplier}\n        {...props}\n      >\n        {children({\n          scale: childScale.times(scaleMultiplier),\n          parentScale: scale,\n          ...props,\n        })}\n      </StickyChild>\n    )\n  }\n}\n\nexport const StickyScrollScene = ({ children, track, stickyLerp, fillViewport, ...props }: any) => {\n  const size = useThree((s) => s.size)\n  const { scaleMultiplier } = useScrollRig()\n\n  const internalRef = useRef(track.current)\n\n  // if tracked element is position:sticky, track the parent instead\n  // we want to track the progress of the entire sticky area\n  const childStyle = useMemo(() => {\n    const style = getComputedStyle(track.current)\n    if (style.position === 'sticky') {\n      internalRef.current = track.current.parentElement\n\n      // make sure parent is relative/absolute so we get accurante offsetTop\n      const parentStyle = getComputedStyle(internalRef.current)\n      if (parentStyle.position === 'static') {\n        console.error(\n          'StickyScrollScene: parent of position:sticky needs to be position:relative or position:absolute (currently set to position:static)'\n        )\n      }\n    } else {\n      console.error('StickyScrollScene: tracked element is not position:sticky')\n    }\n    return style\n  }, [track])\n\n  return (\n    <ScrollScene track={internalRef} {...props}>\n      {renderAsSticky(track, children, size, childStyle, scaleMultiplier, {\n        stickyLerp,\n        fillViewport,\n      })}\n    </ScrollScene>\n  )\n}\n","const _lerp = require('lerp')\n\n/**\n * Drop-in replacement of standard lerp with optional frame delta and target fps\n * to maintain constant animation speed at various fps\n * \n * Based on http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n * \n * @param {number} source Current value\n * @param {number} target Value to lerp towards\n * @param {number} rate Interpolation rate\n * @param {number} frameDelta Optional frame delta time in seconds. Should be 1/60 for a steady 60fps.\n * @param {number} targetFps Optional, target is 60 by default\n * @returns {number} interpolated value\n */\n\nfunction lerp(source, target, rate, frameDelta, targetFps = 60){\n  \n  // return normal lerp if no delta was passed\n  if (typeof frameDelta === 'undefined') {\n    return _lerp(source, target, rate)\n  }\n\n  const relativeDelta = frameDelta / (1 / targetFps)\n  const smoothing = 1 - rate\n  return _lerp(source, target, 1 - Math.pow(smoothing, relativeDelta));\n}\n\nmodule.exports = lerp","function lerp(v0, v1, t) {\n    return v0*(1-t)+v1*t\n}\nmodule.exports = lerp"],"names":["WebGLText","_ref","el","children","material","scale","font","fontOffsetY","fontOffsetX","overrideEmissive","color","props","_objectWithoutPropertiesLoose","_excluded","size","useThree","scaleMultiplier","useScrollRig","textColor","fontSize","textAlign","lineHeight","letterSpacing","useMemo","current","cs","window","getComputedStyle","parentElement","parseFloat","useEffect","emissive","xOffset","React","createElement","Text","_extends","maxWidth","width","overflowWrap","anchorX","anchorY","position","height","WebGLImage","forwardRef","ref","scrollState","vertexShader","fragmentShader","invalidateFrameLoop","widthSegments","heightSegments","useRef","mesh","useImperativeHandle","invalidate","gl","pixelRatio","s","viewport","dpr","scroll","useScrollbar","texture","useImageAsTexture","uniforms","u_color","value","Color","u_time","u_pixelRatio","u_progress","u_visibility","u_viewport","u_velocity","u_res","Vector2","u_rect","u_size","u_texture","u_loaded","u_scaleMultiplier","set","image","useFrame","_","delta","inViewport","x","y","velocity","progress","visibility","args","Fragment","attach","transparent","ParallaxGroup","parallax","ParallaxScrollScene","speed","parallaxAmount","ScrollScene","scissor","inViewportMargin","Math","max","vecTypes","Proxy","get","obj","prop","hasOwnProperty","getVecType","vecn","Array","constructor","dimension","flattenOuter","every","type","TypeError","length","Error","fill","super","this","Reflect","defineProperty","undefined","enumerable","magnitude","pnorm","div","v","checkCompatibility","dim","result","i","minus","neg","times","plus","pow","p","dot","normalize","abs","reflect","normal","n","argmax","maxVal","reduce","acc","concat","argmin","minVal","min","choose","indices","isArray","isIndex","toString","RangeError","forEach","push","copy","equals","approximatelyEquals","epsilon","sum","toArray","from","apply","filter","map","slice","splice","test","validator","Number","swizzleSymbolMap","getSwizzleSymbolMap","newVals","item","split","some","c","valid","unique","SyntaxError","index","swizzleSet","newDim","values","swizzleGet","isNaN","isInteger","classname","VecType","arr","promoteArrayDimension","writable","target","Object","preventExtensions","namedIndices","z","w","r","g","b","a","t","q","find","o","numberValid","prototype","call","src","isVec","vec2","vec3","vec4","add","vecs","multiply","lerp","v1","v2","slerp","theta","acos","relative","cos","sin","_excluded2","StickyChild","childTop","childBottom","parentScale","childScale","priority","stickyLerp","offsetTop","group","yTop","source","rate","frameDelta","targetFps","StickyScrollScene","_ref2","track","fillViewport","internalRef","childStyle","style","console","error","renderAsSticky","top"],"mappings":"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"}
\ No newline at end of file
diff --git a/package.json b/package.json
index 3135a75fc13f7fcf326eb5b2b0cb65e9b0ea9260..062cfa7aa72b4304c236c7b363ce7421e3ae8461 100644
--- a/package.json
+++ b/package.json
@@ -76,6 +76,7 @@
     "@react-three/fiber": "^8.13.3",
     "@types/debounce": "^1.2.1",
     "@types/react": "^18.0.25",
+    "@types/three": "^0.164.1",
     "microbundle": "^0.15.1",
     "react": "^18.1.0",
     "react-dom": "^18.1.0",
