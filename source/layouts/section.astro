---
import type { HTMLAttributes } from "astro/types";

export type Props = HTMLAttributes<"section"> & {
  // Enforce an id for the section.
  id: string;
  order?: number;
  title: string;
};

const { order = 1, title, ...props } = Astro.props;
---

<script>
  type Section = {
    order: number;
    target: HTMLElement;
    visible: boolean;
  };

  function compareSections(a: Element, b: Element) {
    const aOrder = +a.getAttribute("data-observed-section")!;
    const bOrder = +b.getAttribute("data-observed-section")!;

    return aOrder - bOrder;
  }

  function getEntryInfo(entry: IntersectionObserverEntry) {
    const order = +entry.target.getAttribute("data-observed-section")!;
    const visible = entry.isIntersecting;

    return { target: entry.target as HTMLElement, order, visible };
  }

  // We want the latest because there may be multiple sections visible at the same time.
  // The "current" one should always be the (visible) one with the highest order (latest in the document).
  function getLatestVisibleSection(sections: Section[]) {
    const greaterOrder = -Infinity;
    let latest = null;

    for (const section of sections) {
      if (section.order > greaterOrder && section.visible) {
        latest = section;
      }
    }

    return latest;
  }

  // Add the "active" class to the links that point to the currently visible section.
  function updatePageLinks(currentlyVisibleSection: Section) {
    const documentLinks = document.querySelectorAll("a[href^='#']");

    for (const link of documentLinks) {
      const [, target] = link.href.split("#");
      link.classList.toggle(
        "active",
        target === currentlyVisibleSection.target.id,
      );
    }
  }

  document.addEventListener("astro:page-load", () => {
    const sections = [...document.querySelectorAll("[data-observed-section]")];
    sections.sort(compareSections);

    const sectionStates: Record<string, Section> = {};
    let lastVisibleSection: Section;

    const observer = new IntersectionObserver(
      (entries) => {
        // Update the state of each section.
        for (const entry of entries) {
          // The ID is an enforced prop, so we can safely assume it exists.
          const id = entry.target.id;
          sectionStates[id] = getEntryInfo(entry);
        }

        // Find the latest visible section.
        const newLast =
          getLatestVisibleSection(Object.values(sectionStates)) ??
          lastVisibleSection;

        // If there's a new section in view, update the corresponding links.
        if (newLast !== lastVisibleSection) {
          lastVisibleSection = newLast;
          updatePageLinks(lastVisibleSection);
        }
      },
      {
        threshold: 0.3,
        rootMargin: getComputedStyle(document.documentElement).getPropertyValue(
          "--header-height",
        ),
      },
    );

    for (const section of sections) {
      observer.observe(section);
    }
  });
</script>

<section
  {...props}
  data-observed-section={order}
>
  <h2
    class="my-12 ml-2 inline-flex w-full items-center text-pretty font-header text-3xl font-semibold opacity-85 sm:ml-0"
  >
    <span>{title}</span>
    <span class="ml-[0.6em] mt-1 h-0.5 grow translate-y-full bg-muted"></span>
  </h2>

  <slot />
</section>

<style>
  :global(main) {
    counter-reset: section;
  }

  h2 {
    position: relative;
  }

  h2 > span {
    font-size: 0.9em;
  }

  h2::before {
    @apply tabular-nums;

    counter-increment: section;
    content: "0" counter(section) ". ";
    opacity: 0.9;

    margin-top: 0.1em;
    margin-right: 0.5em;

    font-size: 0.8em;
    font-family: theme("fontFamily.sans");
  }
</style>
